# Problem: 11660_구간 합 구하기 5
# Date: 2025-05-17
# Language: Python 3

# 조건
# N×N개의 수가 N×N 크기의 표에 채워져 있음
# (x1, y1)부터 (x2, y2)까지 합을 구하라 ((x, y)는 x행 y열)

# 가정
# 첫째 줄: 표의 크기 N, 합을 구해야 하는 횟수 M  (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100,000)
# 둘째 줄 ~ N개의 줄: 표에 채워져 있는 수가 1행부터 차례대로 주어짐(표 내 정수는 <= 1000 인 자연수)
# 이후 M개의 줄: 네 개의 정수 x1, y1, x2, y2 가 주어짐
#

# 아이디어 : 
# x1~ x2, y1 ~ y2 를 이중 반복문으로 구성하여 이차원 배열의 각 요소들을 가져와 합을 계산함
# 각 합산 내용을 result 배열에 넣고 나중에 출력
# 이게 dp가 필요한가? 싶은데...

#Q1. 2차원 누적합 문제에서, 어떤 방식으로 "누적"을 표현할 수 있을까?
#💡 Hint 1: dp[i][j]는 어떤 영역의 누적합이어야 유용할까?
#💡 Hint 2: 1차원 누적합에서는 sum[i] = sum[i-1] + A[i]였다면, 2차원에서는 어떤 관계일까?
# 지금 2차원으로 배열을 형성하고 누적된 합만 연산하면 되는 문제라, 사실 이것을 dp를 이용하여 구성해야 하는지 의문
# 2차원 배열을 형성한 다음에, (x1, y1), (x2, y2)에 대한 해당 값들을 입력받으면 그것에 따른 2중 반복문 처리하여 각 범위에 따른 요소 합 구하면 되지 않나 싶음
# 아, 혹시 누적합으로 메모이제이션 사용하면... 훨씬 더 빠른 연산이 가능하니까??
# 그렇게 생각하면.. dp를 이차원 배열로 구성하여, 어디부터 시작하여 어디까지 연산하였을 때의 합산 값을 빠르게 표현할 수 있다.
# dp[i][j] = (1,1)부터 시작하여 (i,j)까지 에 대한 합
# A[i][j]는 주어진 배열이라 했을 떄... dp 정의가 맞는지 모르겠네


#Q2. 질의 (x1, y1) ~ (x2, y2)가 주어졌을 때,
#누적합을 어떤 방식으로 빼고 더해야 해당 구간 합이 나올까?

#💡 Hint 1: 그림으로 그려보면 (0, 0) ~ (x2, y2) 직사각형에서
#어떤 부분을 빼야 (x1, y1) ~ (x2, y2)만 남을까?
#💡 Hint 2: 4개의 영역을 생각해보세요 — 전체, 왼쪽, 위쪽, 겹치는 부분

# dp로 정의할 수 있는지는 모르겠는데.. 적어도 A가 주어진 배열이라 했을 때, 
# 우리가 원하는 result = dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1]

import sys
input = sys.stdin.readline

N, M = map(int, input().split())

A = [[0] * (N + 1)]
for _ in range(N):
    A.append([0] + list(map(int, input().split())))

    
dp = [[0 for _ in range(N+1)] for _ in range(N+1)]  

for i in range(1, N+1):
  for j in range(1, N+1):
    dp[i][j] = A[i][j] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]

for i in range (M):
  x1, y1, x2, y2 = map(int, input().split())
  result = dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1]
  print(result)