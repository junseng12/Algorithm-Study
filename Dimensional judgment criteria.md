# 🧠 1차원 vs 2차원 vs 1차원×2

## 1. 차원 선택 기준: 상태 정의에 필요한 조건 개수

| 조건 개수 | 사용 구조             | 예시 문제                      |
| --------- | --------------------- | ------------------------------ |
| 1개       | 1차원 배열 `dp[i]`    | 연속합, 1,2,3 더하기           |
| 2개 이상  | 2차원 배열 `dp[i][j]` | 배낭 문제, RGB 거리, 오르막 수 |

📌 **상태 정의에서 필요한 “기억해야 할 변수 수”가 곧 배열의 차원 수**

---

## 2. 1차원 배열 2개 vs 2차원 배열

| 항목        | 1차원 2개 (`prev`, `curr`)                    | 2차원 배열 (`dp[i][j]`)     |
| ----------- | --------------------------------------------- | --------------------------- |
| 핵심 구조   | 시간 축을 수동 분리 (`swap(prev, curr)`)      | 시간 축 명시 (`dp[i][...]`) |
| 구현 난이도 | 높음 (복잡한 인덱싱, swap 필요)               | 낮음 (직관적)               |
| 메모리 효율 | 중간 (`O(2*K)`)                               | 높음 (`O(N*K)`)             |
| 추천 상황   | 메모리 최적화가 필요하거나 반복이 단순한 경우 | 대부분의 일반적인 문제      |

---

## 3. 감각 정리 요약 (나만의 정의)

### ✅ 1차원 vs 2차원

> “상태를 정의하는 데 필요한 **조건의 수**로 차원을 결정한다.”

### ✅ 1차원 2개 vs 2차원

> “1차원 배열 2개는 사실상 2차원 배열을 **시간축으로 수동 구현**한 것.  
> 시간이 한 칸씩 흐르며 상태가 누적되는 구조에서는 2차원이 더 명확하고 안전하다.”

---

## 4. 실전 팁

- 🚨 `1차원 하나만 사용`할 경우 반드시 **뒤에서부터 갱신**해야 이전 상태 덮어쓰는 실수 방지
- 💡 `dp[i][w]`, `prev[w]`, `curr[w]` 등은 모두 **상태 간 전이 구조만 잘 맞추면** 동일한 의미

---

## 5. 예시 적용: 배낭 문제 (12865)

### 2차원 배열:

```python
dp[i][w] = max(dp[i-1][w], dp[i-1][w - weight[i]] + value[i])
```

### 1차원 배열 2개:

```python
prev = [0] * (K+1)
curr = [0] * (K+1)
for i in range(N):
    for w in range(K+1):
        if w < weight[i]:
            curr[w] = prev[w]
        else:
            curr[w] = max(prev[w], prev[w - weight[i]] + value[i])
    prev, curr = curr, prev
```

### 1차원 배열 (뒤에서부터 갱신):

```python
dp = [0] * (K+1)
for i in range(N):
    for w in range(K, weight[i]-1, -1):
        dp[w] = max(dp[w], dp[w - weight[i]] + value[i])
```

---

## ✅ 최종 정리

> “조건이 1개냐 2개냐가 차원을 결정하고,  
> 상태 간 갱신 흐름에 따라 배열 구조가 최적화될 수 있다.  
> 하지만 명확성과 안정성이 필요한 상황에서는 **2차원이 기본값**이다.”

---
