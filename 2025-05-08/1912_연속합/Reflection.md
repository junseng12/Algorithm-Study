# 💬 Reflection: 연속합 (BOJ 1912)

## 🧠 1. 접근 과정 요약

- 처음엔 단순 누적합 방식으로 접근했지만,
- **이전 누적합이 음수인 경우 새로 시작하는 것이 더 유리하다는 점**을 발견
- 이로 인해 점화식 `dp[i] = max(dp[i-1] + A[i], A[i])`를 유도하게 됨

## 🔄 2. 시행착오 및 사고 흐름

- dp[i]가 무엇을 의미하는지를 명확히 정의하려 노력함
- "이전 연속합 + 현재 값" vs "현재 값만 단독 시작"을 비교하는 방식이 핵심임을 깨달음
- 음수만 존재할 때도 max(dp)가 정확히 최댓값을 추적함을 실험으로 확인

## ✅ 3. 최종 구현 포인트

- dp[0] = A[0] 으로 초기화
- dp[i] = max(dp[i-1] + A[i], A[i])
- 정답은 max(dp)

## 💡 4. 보완 아이디어

- 분기 없이도 로직은 작동하지만, `max(A) <= 0` 조건을 분기 처리하면 코드 의미가 더 명확해짐
- 큰 데이터셋에서도 빠르게 작동하는 간결한 알고리즘 구조임

## 🔁 5. 복습 포인트

- 연속 구간 최적화는 “지금 포함할지 vs 끊고 새로 시작할지”의 선택 문제
- Kadane's Algorithm은 DP의 직관적 사고 훈련에 매우 유효함

## ✍️ 6. 한 줄 소감

> “이어갈지 끊을지를 판단하는 것 — 그게 인생도, 알고리즘도.”
