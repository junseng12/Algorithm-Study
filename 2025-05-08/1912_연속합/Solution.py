# Problem: 1912_연속합
# Date: 2024-05-09
# Language: Python 3

# 조건
# n개의 정수로 이루어진 임의의 수열 주어짐
# 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한 (단 수는 한 개 이상 선택해야 함)

# 가정
# 첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어짐
# 둘째 줄에는 n개의 정수로 이루어진 수열이 주어짐
# 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수


# 아이디어 : 
#❓ Q1. "연속된 부분 수열의 합"을 구하라는 조건에서, 어떤 DP 정의를 생각할 수 있을까?
#dp[i] = ??? 수열 A의 i번째 원소를 포함한 연속합이려면 어떤 조건이 필요할까?
# dp[i]는 이전의 dp[i- 1]였을 때의 최대 연속합의 값이 얼마인지? 알아야 하고 dp[i-1]이 양수인지 음수인지도 파악해야 함
# 그래야 i 원소를 포함하여 dp[i]를 계산할 때, 고려할 연산을 분리할 수 있기 때문이다 (만약 i가 음의 정수여도 이후의 연산에서 최댓값을 만드는 수열 내 부분으로써 활용될 수 있음) 

#❓ Q2. i번째에서 최댓값을 만들기 위한 선택지는?
#Case 1: 이전까지의 합에 A[i]를 이어 붙인다
#Case 2: 아예 A[i]부터 새로 시작한다
 
# 1) dp[i-1]가 음수이면, 당연히 A[i]가 양수일 때, A[i]부터 새로 시작하는 Case 2가 최댓값을 만들기 위한 선택지이다. 
# 2) dp[i-1]가 양수이면, 이전까지의 합에 A[i]을 이어 붙이는 Case1이 최댓값을 만들기 위한 선택지이다.



#❓ Q3. 이 때 점화식은 어떻게 쓸 수 있을까?
#dp[i] = max(dp[i-1] + A[i], A[i]) 이 식의 의미를 너의 말로 설명해줘!
#수열 A의 i번쨰 원소를 포함한 연속합의 최대값인 dp[i]는 이전 i-1번째 원소를 포함한 연속합의 최대와 i번째 원소의 합과 i번쨰 원소 단일 값 중에 큰 것을 고른다.
# 이것의 의미는 dp[i-1], 그러니까 i-1 인덱스까지 구한 최대합이 음수일 경우에는 A[i]부터 다시 최대합을 구하고, 
# dp[i-1]이 양수일 경우에는 A[i]의 값을 포함한 최대합을 구하여 이어간다는 의미이다. (물론, 음수일때 잠시 값이 떨어질 수 있음 근데.. 이후에 쭉 이어서 연속합을 구하다보면 더 커질 수 있으므로.. i의 음수 판별 필요없을 듯)

# dp[i-1]이 음수이고 A[i]가 양수일 경우 => dp[i] = max(dp[i-1] + A[i], A[i]) A[i] 선택
# dp[i-1]이 음수이고 A[i]가 음수일 경우 => dp[i] = max(dp[i-1] + A[i], A[i]) A[i] 선택 될 듯
# dp[i-1]이 양수이고 A[i]가 양수일 경우 => dp[i] = max(dp[i-1] + A[i], A[i]) dp[i-1] + A[i]선택
# dp[i-1]이 양수이고 A[i]가 음수일 경우 => 일단 계산해봐야 한다.. - dp[i] = max(dp[i-1] + A[i], A[i])


n = int(input())
A = list(map(int, input().split()))

dp = [0 for _ in range(n)]
dp[0] = A[0]

#배열 A 내 원소가 모두 음수일 경우(+ 최댓값이 0일때도 포함)
if (max(A) <= 0) :
  print(max(A))
else :
  for i in range(1, n):
    dp[i] = max(dp[i-1] + A[i], A[i])
  
  print(max(dp))