# Problem: 9095_1,2,3 더하기
# Date: 2025-05-13
# Language: Python 3

# 조건
#정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지(자연수의 분할, 다만 3+1, 1+3 다른 것으로 보니까 고려 필요)
#합을 나타낼 때는 수를 1개 이상 사용해야 한
#정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하라

# 가정
# 첫째 줄 입력 : 테스트 케이스의 개수 T
# 둘쨰 줄~ T + 1번째 줄: 각 정수 N  (T번 반복)
# n은 양수이며 11보다 작다

# 아이디어 : 
# 문제가 N 정수를 자연수의 분할 연산하는 것과 유사함. 다만, 1, 2, 3으로만 분할해야 함
# 게다가 1 + 3 과 3 + 1을 구분한다고 하였으므로, 이 분할 과정에서 순열 또한 고려해야 함
# P(n, k) : 똑같이 생긴 n 개의 공을 똑같이 생긴 k개의 상자에 나눠담는 경우의 수 
# if n < k, P(n, k) = 0
# else
# P(n, k) = P(n-k, k) + P(n-k, k-1) + ... +P(n-k, 1) // 이건 모든 경우의 수를 말하는 것
# 여기서 각 상자에 넣는 값이 4이상이면 안되기 떄문에.. 이를 고려해줘야 함
# 이를 어떻게 고려할 지는 잘 생각이 안남.. -> Q2에서 이야기하는 듯

#❓ Q1. dp[n]을 무엇으로 정의할 수 있을까? dp[n] = ???
# dp[n]은 n이라는 정수를 1, 2, 3의 합으로 나타낼 수 있는 최대 방법의 수


#❓ Q2. 어떤 방식으로 n을 만들 수 있을까?→ 마지막에 더해지는 수가 1, 2, 3일 수 있음
#예: dp[n] = dp[n-1] + dp[n-2] + dp[n-3] 왜 이렇게 되는지 네가 직접 설명해볼 수 있을까?
# 앞서 자연수의 분할 내용인  P(n, k) = P(n-k, k) + P(n-k, k-1) + ... +P(n-k, 1)여기서 착안해서
# dp [n]을 더 작은 dp[n-k] 의 합으로 표현하는 식으로 나타낸 것을 말하는 것이다
# 따라서 dp[n][1]이면, dp[n-1][1], dp[n][2] 이면, dp[n-2][2] + dp[n-2][1], dp[n][3]이면, dp[n-3][3] + dp[n-3][2] + dp[n-3][1]
# 약간 요런 느낌을 말하는 것 같은데... 이러면.. 마지막에 더해지는 상자에 넣는 개수가 1, 2, 3인 경우를 말하는 것인데..

# 답변 : 우리는 n을 만드는 마지막 수가 1, 2, 3일 때의 모든 경우를 누적하는 거야.
##각 dp[n-k]는 이미 그 내부에서 어떤 수를 썼든 간에 1, 2, 3만으로 만들어졌기 때문에 4 이상이 들어갈 여지가 아예 없어.

T = int(input())

N = [int(input()) for _ in range(T)]
#dp[n][k] = n을 만들기 위해 마지막으로 사용한 수가 k일 때의 경우의 수
dp = [ 0 for _ in range(max(N) + 1)]
dp[1] = 1
dp[2] = 2
dp[3] = 4

for i in range(4,max(N) + 1):
  dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

for j in N:
  print(dp[j])
  