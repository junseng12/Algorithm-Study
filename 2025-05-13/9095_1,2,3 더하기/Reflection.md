# 💬 Reflection: 1, 2, 3 더하기 (BOJ 9095)

## 🧠 1. 접근 과정 요약

- 자연수 분할 개념에서 출발해 2차원 DP 구조를 떠올림
- 하지만 이 문제는 **순서가 중요한 순열 문제**임을 깨달음
- 최종적으로 `dp[n] = n을 만드는 방법의 수 (순서 있음)`으로 정의를 재정립함
- 핵심 전이: n을 만들 때 마지막 수가 1, 2, 3 중 무엇이냐에 따라  
  → `dp[n] = dp[n-1] + dp[n-2] + dp[n-3]`

## 🔄 2. 시행착오 및 사고 흐름

- 처음에는 조합 기반 정의로 인해 `dp[n][k]` 구조를 상정했지만,  
  실제 필요한 정보는 “이전의 총합”뿐이므로 1차원으로 축소 가능함을 깨달음
- 결정적 깨달음:
  > “점화식은 수식이 아니라, **정의에서 출발**한다.”

## ✅ 3. 최종 구현 포인트

- `dp[n] = n을 만드는 총 경우의 수 (1, 2, 3만 사용, 순서 있음)`
- 초기 조건:
  - `dp[1] = 1`, `dp[2] = 2`, `dp[3] = 4`
- 반복문으로 `dp[4]`부터 `max(N)`까지 채운 뒤 테스트 케이스별 출력

## 💡 4. 보완 아이디어

- 2차원으로 구현한다면 `dp[n][k] = 마지막 수가 k일 때의 경우의 수`로도 가능하지만,
  이 문제에서는 **총합만 필요하므로 1차원으로 최적화 가능**
- 실전에서는 다양한 DP 정의를 스스로 구성하는 연습이 핵심

## 🔁 5. 복습 포인트

- 점화식은 항상 "정의"에서 출발한다
- 문제에서 묻는 것: 총 개수인가, 조합인가, 경로인가?
- 1차원 vs 2차원 DP는 필요한 정보량에 따라 선택하는 것

## ✍️ 6. 한 줄 소감

> “DP는 수식을 암기하는 게 아니라,  
> 문제 정의에 따라 ‘기억할 것’을 스스로 설계하는 일이다.”
