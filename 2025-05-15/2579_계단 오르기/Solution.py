# Problem: 2579_계단 오르기
# Date: 2025-05-15
# Language: Python 3

# 조건
# 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임
# 각 계단에는 일정한 점수가 있고, 이를 밟으면 점수를 얻게됨
# 계단 오르는 규칙 존재
#1) 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
#2) 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
#3) 마지막 도착 계단은 반드시 밟아야 한다.
# 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하라

# 가정
# 첫째 줄에 계단의 개수가 주어짐
# 둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어짐
# 계단의 개수: 300이하의 자연수
# 계단에 쓰여 있는 점수: 10,000이하의 자연수


# 아이디어 : 
# 단순 최대합이므로, 일차원 dp[i]로 문제 해결 가능할 것으로 보임.
# dp[i] i번째 계단에 지점을 밟았을 때, 얻을 수 있는 점수의 최대 합

# 마지막 계단을 밟아야 하기 때문에.. 오히려 거꾸로, 마지막 계단을 밝고 연산하는 걸로 진행하는 것이 유리하다(앞서 잘 계산하다가, 마지막 못 밟게 되면 안되니..)
# dp[i] = max(dp[i-1] + A[i], dp[i-2] + A[i])

# 연속된 세 계의 계단을 밟으면 안되는데, 어떻게 필터링 하는가?
#dp[i] == dp[i-1] + A[i] 이면, dp[i-1] = dp[i-3] + A[i-1] 
# 이렇게 처리하면 되지 않을까? --> 이전에 dp[i]처리했을 때, 무엇을 선택한 지 알 수 없다(근데 서로 다른 경로에 대해 동일한 값일 수도 있으니.. 단순 값만으로 비교 불가)

# dp[i] = max(dp[i-1] + A[i], dp[i-2] + A[i])
# 이렇게 처리하고.. 조건 문 추가하기는 어떨까?
# A[i] = 0 해놓고
# 다음번에는 dp[i] = max(dp[i-1] + A[i], dp[i-2] + A[i]) 이거 연산 전에, A[i+1], A[i+2] 값 미리 확인하는 거지.. 0이면 이미 2번 밟았으니까 못 밟게... 
## dp[i-3] + A[i-1] + A[i]: 한 칸 건너 이전 계단까지는 밟았지만, 두 칸 전을 거쳐 오는 경우 → 이러면 세 칸 연속 방지 가능
# 내 아이디어 중 실수한 부분 -> dp[i-1] + A[i] 연속해서 밟을 수 있는 경우를 필터링 못함..

# dp[i] = max(dp[i-2] + A[i], dp[i-3] + A[i-1] + A[i])

N = int(input())

score = [int(input()) for _ in range(N)]
dp = [0 for _ in range(N)]

if N == 1:
  print(score[0])
elif N == 2:
  print(score[0] + score[1])
else :
  dp[0] = score[0]
  #i번째 계단을 밟을 때, 이전 경로가 정확히 i-1 or i-2 계단에서 왔을 경우만 고려
  dp[1] = max(score[1], score[0] + score[1])
  dp[2] = max(score[1] + score[2], score[0] + score[2])
  for i in range(3, N):
    dp[i] = max(dp[i-2] + score[i], dp[i-3] + score[i-1] + score[i])
  print(dp[N - 1])




