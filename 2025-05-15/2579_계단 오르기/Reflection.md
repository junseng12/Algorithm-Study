# 💬 Reflection: 계단 오르기 (BOJ 2579)

## 🧠 1. 접근 과정 요약

- 처음에는 단순한 최대 점수 합 문제처럼 보였으나, 연속 3계단 금지 조건이 있음을 인식함
- 점화식 설계 전, 상태 정의를 `dp[i] = i번째 계단을 밟았을 때 최대 점수`로 설정
- 경로 중복 없이 올 수 있는 2가지 케이스로 점화식 구성

## 🔄 2. 시행착오 및 사고 흐름

- `dp[i] = dp[i-1] + score[i]`는 세 계단 연속 밟는 상황이 생겨 실패
- A[i+1], A[i+2]를 조건문으로 조작해 연속 밟기 방지하려 했으나, 불완전한 추론임을 인식
- 점화식을 명시적으로 조건 분기하여 재설계함

## ✅ 3. 최종 구현 포인트

- 점화식:
  ```python
  dp[i] = max(dp[i-2] + score[i], dp[i-3] + score[i-1] + score[i])
  ```
- 초기 조건:
  - dp[0] = score[0]
  - dp[1] = max(score[1], score[0] + score[1])
  - dp[2] = max(score[0] + score[2], score[1] + score[2])
- 출력은 반드시 `dp[N-1]` (마지막 계단을 반드시 밟아야 함)

## 💡 4. 보완 아이디어

- 2차원 dp[i][0/1]로 경로 연속 여부를 상태로 나누는 방식도 가능
- 경로 자체를 저장하거나 트레이스백 구조로 확장 가능

## 🔁 5. 복습 포인트

- 상태 정의가 문제의 조건과 직접적으로 연결되어야 함
- 출력 조건이 특정 상태에 국한될 경우, 반드시 점화식과 맞춰야 함
- 점화식은 항상 “도달 가능한 경로의 정의”에서 출발

## ✍️ 6. 한 줄 소감

> “조건이 있는 DP일수록, 점화식은 수식이 아니라 경로 설계이다.”
