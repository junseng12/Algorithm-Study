# 💬 Reflection: 신나는 함수 실행 (BOJ 9184)

## 🧠 1. 접근 과정 요약

- 문제의 조건이 `w(a, b, c)`를 직접 정의해주고 있었기 때문에,  
  점화식을 외우기보다는 조건 분기를 코드로 그대로 옮기는 방식으로 접근함
- 핵심은 "중복 호출"이므로 **3차원 캐시 배열**을 통해 메모이제이션 적용
- 상태 공간이 0~20으로 제한되므로 `dp[21][21][21]` 배열로 충분히 커버 가능

## 🔄 2. 시행착오 및 사고 흐름

- 초기에 단순 재귀 구조로만 구현했을 때 **시간 초과 발생**
- 이후 `dp[a][b][c] is not None` 조건을 삽입하여 **중복 호출 제거**
- 출력 형식을 정확히 `"w(a, b, c) = result"`로 맞추지 않아 Presentation Error 발생 → `f-string`으로 수정

## ✅ 3. 최종 구현 포인트

- 메모이제이션은 `dp[a][b][c]`로 캐싱
- 전체 점화식:
  ```bash
  if a <= 0 or b <= 0 or c <= 0:
      return 1
  if a > 20 or b > 20 or c > 20:
      return w(20, 20, 20)
  if a < b and b < c:
      return w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)
  else:
      return w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)
  ```

## 💡 4. 보완 아이디어

- 재귀 대신 **Bottom-Up DP**로도 구현해볼 수 있음 (단, 조건 분기가 많아 복잡)
- 3차원 배열이 아닌 dictionary로도 메모이제이션 가능 → 메모리 절약형 구현 가능성 실험해보기

## 🔁 5. 복습 포인트

- 메모이제이션은 조건 확인이 선행되어야 함 (`if dp[...] is not None`)
- 출력 포맷 정확성은 반드시 테스트 필요
- 문제에서 정의한 함수를 그대로 코드로 옮기는 능력은 실전에서 매우 중요

## ✍️ 6. 한 줄 소감

> "점화식을 유도하지 않아도,  
> 정의된 구조를 그대로 옮기는 능력도 중요한 역량이다."
