# 💬 Reflection: 알파벳 (BOJ 1987)

## 🧠 1. 접근 과정 요약

- 격자 탐색이라는 점에서 DFS가 적합하다고 판단함.
- 초기에 "그래프를 구성해야 할까?"라는 고민이 있었으나, 이미 2차원 배열로 표현된 격자이므로 인접리스트 형태로 변환할 필요가 없다는 점을 깨달음.
- DFS 중복 방문 방지를 위해 `visited` 배열을 알파벳 기준으로 관리해야 했고, 이를 `set()`으로 표현함.
- DFS를 통해 한 칸 한 칸 이동하면서 "지금까지 지나온 알파벳"을 관리해야 하며, 탐색 후에는 되돌려야 하므로 **백트래킹**이 필수였음.
- 문제 자체는 DFS + 조건 분기이지만, 최적화를 위해 **상태 관리를 bitmask로 전환**하면 훨씬 효율적이다.
- 26개의 알파벳은 최대 26비트로 표현 가능 → `int` 하나로 처리 가능.
- DFS의 상태는 `(x, y, mask)` 세 값으로 구성되며, 이미 이 상태를 탐색한 적 있다면 더 이상 진행하지 않음 → **visited[x][y][mask] 메모이제이션** 도입.

## 🔄 2. 시행착오 및 사고 흐름

- visited를 `[False]`로 노드 기준으로만 생각하려 했지만, 문제는 노드가 아니라 "알파벳 중복"이었음 → set으로 바꿈.
- DFS 함수에 `depth` 변수를 두는 이유를 처음에는 명확히 몰랐지만, **현재까지 이동한 칸 수**를 누적하기 위한 상태 변수라는 걸 깨달음.
- DFS 함수의 종료 조건이 명시적으로 없다는 점이 혼란스러웠으나, 이는 "이동 가능한 다음 칸이 없을 때 자연스럽게 종료"되는 구조라는 점에서 이해함.
- dx, dy 방향 탐색에 대해 처음엔 생소했으나, 반복적인 상하좌우 좌표 이동을 간결하게 표현하는 방식으로 익숙해짐.
- `set()`으로 알파벳을 관리할 때 시간복잡도가 O(N)이 되어, 최대 경로 수 탐색에서 **TLE(시간 초과)** 가능성 존재
- 비트마스크로 바꾸면 알파벳 상태를 O(1) 연산으로 관리 가능
- `visited[x][y][mask]` 메모이제이션이 없으면, 같은 위치에서 같은 알파벳 상태로 중복 탐색 발생 → 불필요한 계산 낭비

## ✅ 3. 최종 구현 포인트

- DFS 함수에서:

  - `visited.add()`로 현재 알파벳 기록
  - 사방 탐색에서 방문 조건 검사
  - 모든 자식 탐색 후 `visited.remove()`로 복귀 (백트래킹)

- 방향 탐색 배열:

  ```python
  dx = [-1, 1, 0, 0]  # 상하
  dy = [0, 0, -1, 1]  # 좌우
  ```

- 알파벳 상태 관리를 비트마스크로 구현:
  ```python
  next_ch = ord(board[nx][ny]) - ord('A')
  if not (mask & (1 << next_ch)):
      dfs(nx, ny, mask | (1 << next_ch), depth + 1)
  ```

* 방문 체크는 3차원 visited 배열로 관리:

  ```python
  if visited[x][y][mask]:
      return
  visited[x][y][mask] = True
  ```

* DFS 종료 조건 없이 자연스럽게 **더 이상 갈 수 없을 때 종료됨**

## 🔍 성능 비교

| 관리 방식 | 시간 복잡도   | 공간 복잡도   | 구현 난이도 |
| --------- | ------------- | ------------- | ----------- |
| set       | O(N) per call | O(N)          | 쉬움        |
| bitmask   | O(1) per call | O(2^26 × N^2) | 중간\~높음  |

## 🚫 실수 포인트

- (i, i) 좌표에 무조건 1 넣는 DFS 패턴이 여기서는 적용되지 않음 (경로로 도달해야만 인정)
- visited를 "위치"가 아닌 "알파벳" 기준으로 관리해야 한다는 점에서 기존 DFS 감각과 차이 있었음
