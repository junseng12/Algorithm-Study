# Problem: 11057_오르막수
# Date: 2024-05-02
# Language: Python 3

# 조건
#오르막 수: 수의 자리가 오름차순을 이루는 수 , 인접한 수가 같아도 오름차순으로 친다
#수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램
#수는 0으로 시작할 수 있다. => 0도 오르막수에 포함된다!
# 첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력

# 가정
#N (1 ≤ N ≤ 1,000)

# 아이디어 : 
# 어떤 수를 입력받았을 때, 그 수를 리스트에 저장한다. 이를 정렬한 것이 원본과 같은 경우, 이 수는 오르막수 이다.
# N값을 입력 받으면, 그 N 자리의 수를 모두 돌아보면서, 정렬시켰을때, 조건에 맞는 것들의 경우에만 덧셈하여 개수 세기 => 시간 내 처리할 수 있을까?
# 그렇다면, 자리 수를 입력받았을 때, 첫째 자릿수의 선택이 이후의 숫자 선택에 영향을 끼치게 됨. (현재 선택이 미래 선택에 영향 끼치게 됨) -> 역방향 고려

# 질문
#❓ Q1. 오르막 수라는 건 구체적으로 어떤 규칙을 의미할까?
# 해당 숫자 자체가 오름차순으로 정렬된 수

#❓ Q2. N = 1일 때 가능한 오르막 수는 어떤 게 있을까?→ 그 수들을 어떻게 “자릿수”로 일반화할 수 있을까?
# N=1 이라면, 0~9 모두 한 자리수는 모두 스스로 오름차순으로 정렬된 수이기 때문에, 모두 오르막수 이다. 뒷 자리수에서부터 0~9중에 하나씩 선택하면서 앞으로 자릿수를 높여가며 가능한 개수를 세는 방식으로 

#❓ Q3. “이전 자릿수의 상태로부터 현재 자릿수의 경우의 수를 전이한다”는 관점에서→ 어떤 상태(정보)를 저장해야 할까?
# 나는 현재 선택이 미래 선택의 폭을 좌우한다고 생각했음. 따라서 맨 뒷자리수부터 고려하면 전체 자릿수를 쉽게 연산할 수 있다고 생각해서,, 역방향으로 DP 를 진행하면 되지 않나고 생각했음

#❓ Q4. 이 문제를 dp[i][j] 형태로 설계하면,→ 각각 i와 j는 무엇을 의미해야 할까?
# i자리 수 중에서, 마지막 자리가 j인 오르막 수의 개수를 저장하는 2차원 테이블
# dp[i][j] = 길이가 i이고, 마지막 숫자가 j인 오르막 수의 개수
# dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1] + dp[i-1][j]

N = int(input())

dp = [[0 for _ in range(10)] for _ in range(N + 1)]

#dp[1][k] 는 모두 1로 초기화
for k in range(10):
  dp[1][k] = 1

for i in range(2, N+1):
  for j in range(10):
    if j == 0:
            dp[i][j] = dp[i - 1][j]
    else:
      dp[i][j] = dp[i][j-1] + dp[i-1][j]


print(sum(dp[N]) % 10007)