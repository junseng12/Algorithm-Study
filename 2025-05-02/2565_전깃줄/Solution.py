# Problem: 2565_전깃줄
# Date: 2024-05-02
# Language: Python 3

# 조건
# 노드 A와 B는 10층으로 구성된 건물이다. 
# 두 건물 사이에 전깃줄을 연결할 때, 교차선은 합선의 위험이 있어 주어진 입력값(건물 사이에 연결된 선들)에 대해 제거해야 하는 최소 교차선의 개수를 제시하라

# 가정
# 첫째 줄에는 두 전봇대 사이의 전깃줄의 개수 N이 제시됨 (N <=100)
# 둘째 줄부터는 긱 전깃줄이 어떻게 연결되어 있는지 위치 번호 쌍을 입력함(N번, 위치 번호 <- 500 이하의 자연수)

# 아이디어 : 
# 연결되어 있는 위치 번호 쌍의 차가 큰 것들을 위주로 제거하면 유리할 것 같음
# 이게 아닐 경우는 어떤 경우가 있을까? 

#1. 전깃줄을 겹치지 않게 한다는 건 어떤 의미일까? → 두 줄이 서로 “교차”하는 경우는 어떤 조건에서 발생하지?
# 어느 한 전깃줄의 위치 번호 쌍에 대해 다른 전깃줄의 위치 번호 쌍이 첫번째 원소 값은 크지만, 두번째 원소 값은 작은 경우
  
#2. 한쪽(A)을 기준으로 정렬하면, → 다른 쪽(B)의 전깃줄 구조는 어떤 수열처럼 볼 수 있을까?
# 한쪽(A)을 기준으로 정렬했다면... 다른 쪽의 전깃줄 구조는 교차선 제외하면, 증가하는 수열이 되어야 할 것이다.

#3. 그 수열에서 겹치지 않게 남길 수 있는 전깃줄 최대 개수는 → 어떤 알고리즘 문제로 바꿔서 풀 수 있을까?
# 위의 한쪽 기준으로 정렬한 다음에.. 이전에 가장 길게 선택할 수 있는 부분수열의 길이를 구하는 문제에서 활용했던 DP 방법을 통해 계속해서 선택하여 그 길이를 구하는 것으로 구현할 수 있을 것 같음.
  
#4. 결국 남기지 못한 전깃줄 수는 어떤 방식으로 계산할 수 있을까?
#  LIS 길이를 구하고 전체 길이에서 그 길이만큼 뺴면 제거해야 하는 최소 교차선의 개수일 것 같음


N = int(input())

A =[]

for i in range(N) :
  A.append(list(map(int, input().split())))

# 한쪽 전깃줄에 대해 정렬하기(값을 리스트로 저장해서 첫번쨰 원소 기준으로 정렬하기 - 정렬에 따라 두번째 원소들도 자동으로 순서 이동 이루어짐)
sorted_A = sorted(A, key=lambda x: x[0])

#print(sorted_A)
# 기본적으로 자기 자신만 포함하는 수열은 길이 1
dp = [1 for _ in range(N)]

# B 그러니까 sorted_A의 두번째 원소들에 대하여, LIS 값 구하기
for i in range(N):
  for j in range(i):
    if (sorted_A[j][1] < sorted_A[i][1]):
      dp[i] = max(dp[i], 1 + dp[j])

# 과거 값에서 이어지는 것과 현재부터 시작하는 것 중 최대 값 선택 -> 이전 값이 현재의 선택에 이어짐 -> 순방향
#dp[i] = max(dp[i], 1 + dp[j]) (j < i이고, dp[j] < dp[i]) 

# 전체 길이 - LIS 값 = 제거해야 하는 최소 교차선의 개수
print(N - max(dp))

