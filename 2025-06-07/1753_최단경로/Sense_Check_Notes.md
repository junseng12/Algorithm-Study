# 📌 감각 메모

## 🔍 \[문제 이름]: `1753 - 최단경로`

---

### 1. **Dijkstra 함수(루프)에서 어떤 변수를 관리/매개변수로 둘 것인가? (→ 상태 전달 요소)**

> **기준**: "탐색 도중 바뀌는 값 = 우선순위 큐로 관리", "전체 탐색 동안 유지해야 할 값 = distance 배열"

| 변수               | 역할                                    | 매개변수 여부               | 이유                                                  |
| ------------------ | --------------------------------------- | --------------------------- | ----------------------------------------------------- |
| `queue`            | (현재까지 거리, 노드) 우선순위 큐       | ✅ Yes (함수 내부에서 관리) | 현재까지 발견된 가장 가까운 노드를 먼저 처리하기 위해 |
| `distance[노드]`   | 시작 노드로부터 각 노드까지의 최단 거리 | ❌ No (전역 배열로 사용)    | 전체 탐색 동안 유지해야 하고 전역적으로 업데이트 필요 |
| `current_distance` | queue에서 pop된 노드까지의 거리         | ✅ Yes (pop 시 사용)        | 현재 pop한 노드까지의 거리로 탐색 조건 분기 시 필요   |
| `current_node`     | queue에서 pop된 노드                    | ✅ Yes (pop 시 사용)        | 인접 노드 탐색의 기준 노드가 됨                       |

---

### 2. **백트래킹 포인트는 어디인가? (→ 상태 복원 위치)**

> Dijkstra는 "최적 경로만 남기고 잘라내는 방식"이라 명시적 백트래킹은 필요 없음 → 대신 "distance가 이미 갱신된 노드 처리 건너뛰기"가 일종의 "잘라내기" 역할.

- 상태 "복원"은 아님 → **불필요한 경로를 prune(잘라냄) 하는 로직**만 존재:

```python
if current_distance > distance[current_node]:
    continue
```

- 💡 이 부분이 Dijkstra에서는 **사고의 핵심 포인트**임 → **이미 더 짧은 경로가 발견된 노드는 다시 탐색 X**

---

### 3. **상태 변화의 최소 단위는 무엇인가? (→ 탐색 단계별 변화 단위)**

| 요소               | 최소 변화 단위                             |
| ------------------ | ------------------------------------------ |
| `distance[노드]`   | 새로운 더 짧은 경로 발견 시 업데이트       |
| `queue`            | 새로운 후보 노드 발견 시 (거리, 노드) 추가 |
| `current_distance` | heapq에서 pop될 때마다 변경됨              |
| `current_node`     | heapq에서 pop될 때마다 변경됨              |

---

### 4. **탐색 대상은 누구인가? (→ 자식 노드 정의)**

> 현재 pop된 `current_node`에서 \*\*인접한 모든 노드(adj_node)\*\*가 탐색 대상.

- 탐색 대상 정의:

```python
for adj_node, weight in graph[current_node]:
    if distance[adj_node] > current_distance + weight:
        distance[adj_node] = current_distance + weight
        heapq.heappush(queue, (distance[adj_node], adj_node))
```

- 💡 인접 노드가 "현재까지 발견된 거리보다 더 짧으면 → 업데이트 후 탐색 대상(큐)에 추가"

---

### 5. **기저 조건(Base case)은 어디인가?**

> Dijkstra는 일반적으로 **queue가 빌 때까지 반복** → 명확한 "기저 조건"은 while loop 종료 조건으로 처리.

```python
while queue:
    # 반복
# queue가 빌 때 탐색 종료
```

- 💡 다익스트라는 "경로의 깊이 기반" 탐색이 아니라 "가장 가까운 노드부터 처리"이므로 DFS처럼 depth 기반 기저 조건이 아님.

---

### 6. **그 외 이 문제에서 특이하게 고려할 요소는?**

| 요소                                     | 설명                                                              |
| ---------------------------------------- | ----------------------------------------------------------------- |
| ✅ 가중치가 있는 방향 그래프임           | BFS로 처리 불가 → Dijkstra 필요                                   |
| ✅ queue에 동일 노드가 여러 번 push 가능 | pop 시 distance 비교로 더 나쁜 경로는 자동 skip                   |
| ✅ INF 초기화 필요                       | distance 배열 초기값은 INF로 두어야 갱신이 올바르게 작동함        |
| ✅ 우선순위 큐(heapq) 필수 사용          | 가장 가까운 노드 pop 순서를 보장해야 최단 경로가 성립함           |
| ❌ 명시적 visited 배열 불필요            | distance 값 비교로 visited 역할을 충분히 대체 가능                |
| ❌ graph 필요 없음                       | 그래프 순회는 adjacency list 기반으로 구현하므로 별도 구조 불필요 |

---

## 🏁 최종 요약

| 항목               | 현재 문제에서의 적용                                                           |
| ------------------ | ------------------------------------------------------------------------------ |
| ✅ 매개변수 선정   | queue 내부에서 (distance, node) 튜플 관리                                      |
| ✅ 백트래킹 포인트 | 명시적 복원 X → distance 값 비교 후 pruning (continue 처리)                    |
| ✅ 상태 최소 단위  | distance\[노드], queue 상태, current_distance, current_node                    |
| ✅ 탐색 대상       | current_node의 인접 노드 모두                                                  |
| ✅ 기저 조건       | queue가 빌 때까지 → 모든 노드의 최단 거리 보장                                 |
| ✅ 특이 요소       | heapq 사용 필수 / INF 초기화 필수 / visited 배열 불필요 → distance 비교로 대체 |

---
