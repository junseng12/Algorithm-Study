# 🧠 탐색 유형 판별 및 설계 노트

---

## 단계별 판별 흐름 (Step by Step)

### 🚩 Step 1: 탐색 공간 구조 먼저 파악하기

| 질문                                                   | 해석                  |
| ------------------------------------------------------ | --------------------- |
| 문제가 그래프 구조인가? (노드/간선, 연결 상태 묘사됨?) | → BFS / DFS 우선 고려 |
| 문제가 트리형 경우의 수 탐색인가?                      | → DFS 우선 고려       |
| 문제가 순차적 최적화/누적 결과를 요구하는가?           | → DP 우선 고려        |

---

### 🚩 Step 2: 목표가 무엇인가?

| 목표 유형                              | 추천 탐색 유형 | 설명                                                          |
| -------------------------------------- | -------------- | ------------------------------------------------------------- |
| 최단 거리 구하기                       | BFS            | 최단 거리 탐색은 BFS가 최적 (최초 방문 시 최단 거리 보장)     |
| 모든 경우 탐색 (가능한 경우 모두 확인) | DFS            | 트리형 모든 경우의 수 탐색 (부분수열, 순열, N-Queen 등)       |
| 최적 값 구하기 (최대합, 최소합 등)     | DP             | 부분 문제 최적 결과 누적 필요                                 |
| 경로 존재 여부 확인                    | BFS / DFS      | 경로가 존재하는지만 확인하면 BFS / DFS 모두 가능              |
| 경우의 수 세기                         | DFS / DP       | 중복 여부 판단 후 결정 (중복 허용 → DP, 중복 없음 → DFS 가능) |

---

### 🚩 Step 3: 중복 탐색 가능성 / DP 여부 판별

| 질문                                          | 판단 기준                       |
| --------------------------------------------- | ------------------------------- |
| 동일한 상태에 대해 여러 경로로 도달 가능한가? | → DP 필요 (중복 계산 제거 필요) |
| 상태가 고유하게 한 방향으로만 진행되는가?     | → DFS / BFS로 충분              |

※ 중복 → "메모이제이션 DFS" or DP로 풀어야 시간 내 통과 가능
※ 중복 없으면 DFS로 모든 경우 탐색해도 OK

---

### 🚩 Step 4: 시간/공간 조건 체크

| 조건                                      | 추천                    |
| ----------------------------------------- | ----------------------- |
| N <= 10^5 이고 최단 거리                  | BFS                     |
| 경우의 수가 2^N 정도고 N이 작음 (N <= 20) | DFS                     |
| 경우의 수가 많고 최적 값 요구             | DP                      |
| 그래프 탐색인데 깊이가 깊음               | DFS + visited 주의 필요 |

---

## 각 개념 정리 & 설계 방식 detail

---

### 📌 BFS

#### 🔍 개념

- 레벨 단위로 순차적으로 탐색
- Queue 사용 → 최초 방문 시 해당 노드까지 최단 거리 보장

#### 🛠️ 설계 패턴

```python
q = deque()
q.append(start)
while q:
    cur = q.popleft()
    for next in adj[cur]:
        if not visited[next]:
            visited[next] = True
            q.append(next)
```

#### 🧠 경험적 판단 기준

- "최소 거리"라는 말이 나오면 무조건 BFS 먼저 생각
- "최소 이동 횟수"도 동일
- BFS는 **모든 경우를 같은 레벨로 확장**하므로 최단 거리 보장

#### ⚠️ 흔한 실수

- visited 체크를 빼먹어서 무한루프 발생
- Queue 대신 Stack 사용 → DFS처럼 동작 (틀림)

#### 🚀 설계 최적화 팁

- BFS는 "한 번 방문한 노드는 다시 방문하지 않음" → visited 체크로 빠르게 가지치기 가능
- 최단 거리 기록을 위해 dist 배열 사용 가능

---

### 📌 DFS

#### 🔍 개념

- 깊이 우선 탐색 → Stack 기반 (재귀 or 명시적 Stack)
- 트리형 경우의 수 탐색에 매우 적합

#### 🛠️ 설계 패턴

```python
def dfs(depth):
    if depth == target:
        process()
        return
    for candidate in candidates:
        dfs(depth + 1)
```

#### 🧠 경험적 판단 기준

- 경우의 수를 모두 "직접 확인해야 하는 경우" → DFS 적합
- "모든 경로", "모든 조합", "모든 순열"이 필요할 때

#### ⚠️ 흔한 실수

- Base Case 조건을 빼먹어 무한 재귀 발생
- 상태 복원을 빼먹어서 잘못된 경우 세기 발생

#### 🚀 설계 최적화 팁

- **상태 복원 시점을 정확히 잡는 연습** 필요 → visited, sum 등 복원 주의
- 경우의 수가 많을 경우 pruning 조건을 명확히 설계

---

### 📌 DP

#### 🔍 개념

- 중복 하위 문제 결과를 재활용
- 최적 부분 문제 결과 누적

#### 🛠️ 설계 패턴

```python
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
```

#### 🧠 경험적 판단 기준

- "최적 값"이라는 말이 나오면 DP 후보
- "중복 상태가 발생하는 구조"면 DP 고려
- "최대합, 최소합, 경우의 수 세기" 유형 → DP가 강력함

#### ⚠️ 흔한 실수

- dp 배열의 의미를 명확히 정의하지 않아서 설계 단계에서 꼬임 발생
- 점화식을 정확히 쓰지 못해 틀리는 경우 다수

#### 🚀 설계 최적화 팁

- 반드시 **dp\[i]의 의미를 글로 적어보고 시작** (설명할 수 없으면 설계가 틀린 것)
- 1차원 최적화 가능 여부 확인 후 적용 (특히 배낭문제 등에서 메모리 줄일 수 있음)

---

## 4️⃣ 실전 판별 흐름 예시 (Step by Step 적용)

### 예시 문제 1: 미로 탐색 (BFS)

→ [https://www.acmicpc.net/problem/2178](https://www.acmicpc.net/problem/2178)

Step 1. 그래프 구조 → YES → BFS/DFS 후보
Step 2. 최단 거리 → BFS 선택
Step 3. 중복 탐색 여부 → 방문처리로 해결 → BFS 적합
Step 4. 시간/공간 → BFS 처리 가능

→ 결론: BFS 사용

---

### 예시 문제 2: 부분수열의 합 (DFS)

→ [https://www.acmicpc.net/problem/1182](https://www.acmicpc.net/problem/1182)

Step 1. 트리형 경우의 수 → DFS 구조
Step 2. 모든 경우 탐색 → DFS 적합
Step 3. 중복 탐색 여부 → 상태 고유 → DFS 적합
Step 4. 시간/공간 → DFS 처리 가능

→ 결론: DFS 사용

---

### 예시 문제 3: 배낭 문제 (DP)

→ [https://www.acmicpc.net/problem/12865](https://www.acmicpc.net/problem/12865)

Step 1. 순차적 최적화/누적 결과 필요 → DP 구조
Step 2. 최적 값 구하기 → DP 적합
Step 3. 중복 탐색 여부 → O(N\*K) 필요 → DP 사용 필수
Step 4. 시간/공간 → DP로 효율적 처리 가능

→ 결론: DP 사용

---

## 5️⃣ 최종 1줄 사고 흐름

```markdown
1️⃣ 탐색 공간 구조 먼저 파악 → 그래프? 트리형? 순차적 계산?
2️⃣ 목표 파악 → 최단 거리 / 경우 탐색 / 최적 결과?
3️⃣ 중복 탐색 여부 파악 → 있으면 DP 필요
4️⃣ 시간/공간 조건 체크 → 적합한 탐색 방법 선택
```

---

## ✅ 요약

| 탐색 유형 | 가장 잘 쓰이는 상황                            |
| --------- | ---------------------------------------------- |
| BFS       | 최단 거리 탐색 / 레벨 순서 탐색                |
| DFS       | 모든 경우의 수 탐색 / 특정 조건 만족 경로 찾기 |
| DP        | 중복 하위 문제 존재 / 최적 결과 필요 시        |

---
