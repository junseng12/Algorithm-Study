# 🧠 DP 설계 유형 비교 노트: 1차원 vs 2차원 vs 1차원×2

## 1. 차원 선택 기준: 상태 정의에 필요한 조건 개수

| 조건 개수 | 사용 구조             | 예시 문제                      |
| --------- | --------------------- | ------------------------------ |
| 1개       | 1차원 배열 `dp[i]`    | 연속합, 1,2,3 더하기           |
| 2개 이상  | 2차원 배열 `dp[i][j]` | 배낭 문제, RGB 거리, 오르막 수 |

📌 **상태 정의에서 필요한 “기억해야 할 변수 수”가 곧 배열의 차원 수**

---

## 2. 1차원 배열 2개 vs 2차원 배열

| 항목        | 1차원 2개 (`prev`, `curr`)                    | 2차원 배열 (`dp[i][j]`)     |
| ----------- | --------------------------------------------- | --------------------------- |
| 핵심 구조   | 시간 축을 수동 분리 (`swap(prev, curr)`)      | 시간 축 명시 (`dp[i][...]`) |
| 구현 난이도 | 높음 (복잡한 인덱싱, swap 필요)               | 낮음 (직관적)               |
| 메모리 효율 | 중간 (`O(2*K)`)                               | 높음 (`O(N*K)`)             |
| 추천 상황   | 메모리 최적화가 필요하거나 반복이 단순한 경우 | 대부분의 일반적인 문제      |

---

## 3. 감각 정리 요약 (나만의 정의)

### ✅ 1차원 vs 2차원

> “상태를 정의하는 데 필요한 **조건의 수**로 차원을 결정한다.”

### ✅ 1차원 2개 vs 2차원

> “1차원 배열 2개는 사실상 2차원 배열을 **시간축으로 수동 구현**한 것.  
> 시간이 한 칸씩 흐르며 상태가 누적되는 구조에서는 2차원이 더 명확하고 안전하다.”

---

## 4. 실전 팁

- 🚨 `1차원 하나만 사용`할 경우 반드시 **뒤에서부터 갱신**해야 이전 상태 덮어쓰는 실수 방지
- 💡 `dp[i][w]`, `prev[w]`, `curr[w]` 등은 모두 **상태 간 전이 구조만 잘 맞추면** 동일한 의미

---

## 5. 예시 적용: 배낭 문제 (12865)

### 2차원 배열:

```python
dp[i][w] = max(dp[i-1][w], dp[i-1][w - weight[i]] + value[i])
```

### 1차원 배열 2개:

```python
prev = [0] * (K+1)
curr = [0] * (K+1)
for i in range(N):
    for w in range(K+1):
        if w < weight[i]:
            curr[w] = prev[w]
        else:
            curr[w] = max(prev[w], prev[w - weight[i]] + value[i])
    prev, curr = curr, prev
```

### 1차원 배열 (뒤에서부터 갱신):

```python
dp = [0] * (K+1)
for i in range(N):
    for w in range(K, weight[i]-1, -1):
        dp[w] = max(dp[w], dp[w - weight[i]] + value[i])
```

---

## ✅ 최종 정리

> “조건이 1개냐 2개냐가 차원을 결정하고,  
> 상태 간 갱신 흐름에 따라 배열 구조가 최적화될 수 있다.  
> 하지만 명확성과 안정성이 필요한 상황에서는 **2차원이 기본값**이다.”

---

# 🧠 DP 설계 유형 비교 노트 → 확장 메모 (DFS / 백트래킹 감각 포함)

## 6. DP 문제 vs DFS/백트래킹 문제 사고 구분

| 질문                                | DP에 가까운 경우                    | DFS/백트래킹에 가까운 경우                |
| ----------------------------------- | ----------------------------------- | ----------------------------------------- |
| 내가 원하는 것은?                   | "최적 부분 문제의 결과 누적"        | "가능한 모든 경우를 탐색"                 |
| 동일 상태에서 중복 탐색 가능한가?   | 안 됨 → 메모이제이션/DP 테이블 필요 | 중복 허용 가능 (하지만 pruning 시도 가능) |
| 현재 상태가 고정된 단계적 계산인가? | 그렇다 → DP 적합                    | 아니다 → 트리형 탐색이 필요할 수 있음     |
| 탐색 대상이 명확하게 정의되는가?    | 그렇다 (테이블 인덱스로 전이 명확)  | 재귀 구조 안에서 탐색 대상이 유동적이다   |
| 상태 복원 필요 여부                 | 보통 필요 없음 (갱신만 진행)        | 필요함 (백트래킹에서 설정 후 복원 필수)   |

---

## 7. 탐색 대상 / 상태 최소 단위 → 구분 사고 메모

| 패턴 유형    | 탐색 대상 정의 감각                      | 상태 최소 단위             |
| ------------ | ---------------------------------------- | -------------------------- |
| DP           | 테이블 상의 index 전이                   | dp\[i], dp\[i]\[j] 등      |
| 조합형 DFS   | 현재 깊이(row 등)에서 선택 가능한 후보군 | row, col, 선택 여부 등     |
| 그래프형 DFS | 현재 노드에서 이동 가능한 연결 노드      | 현재 노드, visited 여부 등 |
| 순열/조합    | 현재 위치에서 가능한 원소 선택/비선택    | 선택 여부, index 등        |

→ **문제를 처음 보면 "탐색 대상 정의를 먼저 한다"는 습관화 추천**

---

## 8. DFS형 문제 설계 시 체크리스트

```markdown
✅ 현재 상태는 무엇인가? (ex. row, col, sum, visited 등)
✅ 자식 노드는 어떻게 정의되는가? (탐색 대상)
✅ 기저 조건은 어디에 두는가? (Base Case 명확히 정의)
✅ 탐색 후 어떤 상태 복원이 필요한가? (visited 등 복원 여부 확인)
✅ 중복 탐색이 발생하는가? → 발생 시 DP로 전환 고려
```

---

## 9. DP vs DFS/백트래킹 → 실전 적용 팁

### 🚨 내가 풀 문제를 보고 다음 질문을 해보자:

1️⃣ 이 문제는 "모든 경우를 다 탐색해야 하는가?"
→ Yes → DFS/백트래킹 적합 가능성 높음

2️⃣ 동일 상태에서 중복 계산이 발생할 것 같은가?
→ Yes → DP 적용 가능성 높음

3️⃣ 상태 전이가 명확히 정의되는가 (dp\[i], dp\[i]\[j] 등)?
→ Yes → DP 구조화 진행

4️⃣ 탐색 대상(자식 노드) 정의가 자연스러운가?
→ Yes → DFS 재귀 구조 적합

---

## 10. 나만의 사고 메모 한 줄 정리

> "이 문제는 **트리형 탐색 문제인가(DFS)**, 아니면 **상태 누적 최적화 문제(DP)** 인가를 항상 먼저 구분하자.
> 탐색 대상 정의 → 상태 최소 단위 → 기저 조건 → 복원 여부 → 이 흐름으로 설계하면 실패 확률이 확 줄어든다."

---
