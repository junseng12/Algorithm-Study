# Problem: 1197_최소 스패닝 트리
# Date: 2025-06-10
# Language: Python 3

# 조건
# 그래프 주어였을 때, 그 그래프의 최소 스패닝 트리 구하라
# 최소 스패닝 트리 : 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리


# 가정
# 첫째 줄: 정점의 개수 V(1 ≤ V ≤ 10,000), 간선의 개수 E(1 ≤ E ≤ 100,000)
# 두번쨰 ~(E개의 줄) : 각 간선에 대한 정보를 나타내는 세 정수 A, B, C(A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있음)
# C는 음수일 수도 있으며, 절댓값이 1,000,000 넘지 않음
# 최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어짐

# 아이디어 : 
# 내가 알고 있기로, MST 구현하기 위해서는 Kruskal 알고리즘이나 Prim 알고리즘을 사용하여 만드는 것이 일반적임
# 해당 알고리즘 개념을 정확히 알고 있지 않기에.. 조금 더 공부하고 코드화하고자 함

# 두 알고리즘 사이에 어떤 것들을 선택해야 하느지 명확히 아직은 판단이 안되므로
# 일단 Kruskal 알고리즘을 이용하여 구현하려고 함
# MST가 1) 최소 비용의 간선으로 구성되며, 2) 사이클을 이루지 않음 을 조건으로 하고 있기에
# Kruskal 알고리즘의 방향과 같이.. 각 단계에서 사이클을 이루지 않고 최소 비용의 간선을 선택하도록 해야 함

# 인터넷에서 본 과정은 다음과 같다

# [과정]

# 그래프의 간선들을 가중치의 오름차순으로 정렬한다.
# 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.
# 즉, 가장 낮은 가중치를 먼저 선택한다.
# 사이클을 형성하는 간선을 제외한다.
# 해당 간선을 현재의 MST(최소 비용 신장 트리)의 집합에 추가한다.

# 오름차순 정렬 -> 가중치 기중으로 heapq 이용하여 넣기(정렬됨)
# pop() 하여 (가장 가중치 낮은) 간선 선택하여 진행하며, 만약 사이클을 이룬다면 제외(if문으로 필터링)
  # 사이클 판단하는 기준알아야 할 듯
# 문제가 없다면 현재 MST 집합에 추가하여 포함된 집합 내 간선이 V-1이 될 떄까지(종료 조건) 진행함



# Q1-1. MST(최소 스패닝 트리)란 무엇인가?
# (스스로 간단히 정의해보자)
# 최소 비용으로 모든 노드를 연결한 트리

# Q1-2. MST가 주어질 때, "최소"가 의미하는 것은 무엇인가?
# (무엇을 최소화하는가?)
# 연결된 간선의 가중치의 합이 최소가 되도록 함

# Q1-3. MST를 구하기 위한 알고리즘으로 어떤 것들이 있는가?
# (알고 있는 MST 알고리즘들 나열해보기 — 정확히 몰라도 괜찮음)
# Kruskal, Prim 알고리즘

# Q1-4. 이번 문제에서는 어떤 MST 알고리즘을 쓰는 것이 적합할까? 왜?
# (이 문제의 조건(E ≤ 100,000 등) 고려해서 어떤 알고리즘을 선택하면 좋은지 생각해보기)
# 간선이 10^5 정도니까.. O(N^2)(프림), O(eloge)(크루스칼) 이 둘의 시간 복잡도를 비교하니까.. 크루스칼 알고리즘 이용하는게 나을 것이라 생각함

# Q1-5. MST 알고리즘 구현 시, 어떤 자료구조가 필요할까? (특히 Kruskal 알고리즘 쓴다면?)
# (사이클 방지 / 집합 관리에 어떤 자료구조가 필요할지 생각해보자)
# 사이클 방지는 그냥 그래프 처리하면 확인할 수 있을 것 같고, 집합 관리라면 넣을 때마다 알아서 오름차순으로 정렬해주는 heapq 사용하면 좋을 것 같음

import sys

input = sys.stdin.readline

sys.setrecursionlimit(10**6)

V, E = map(int, input().split())

#Kruskal 알고리즘에서 일반적으로 간선 오름차순 정렬하는 방법 - sort()
edges = [] # 간선 목록 (가중치, u, v)
for _ in range(E):
    u, v, w = map(int, input().split())
    edges.append((w, u, v))

edges.sort()  # 가중치 기준으로 정렬 (heapq 없이 그냥 sort())


total_weight = 0 # MST 가중치 총합
edge_count = 0  # 현재 MST에 포함된 간선 개수 (V-1개 확인용)

parent = [i for i in range(V+1)]   # Union-Find parent 리스트(초기에는 자기 자신이 부모)

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])  # 경로 압축
    return parent[x]

def union(x, y):
    x_root = find(x)
    y_root = find(y)
    if x_root != y_root:
        parent[y_root] = x_root  # 또는 rank 기준으로 최적화 가능

def Kruskal ():
  global total_weight
  global edge_count
  
  for  w, u, v in edges:
    if find(u) != find(v):
      union(u, v)
      total_weight += w
      edge_count += 1
      
      if (edge_count == V - 1):
        break
      
Kruskal()

print(total_weight)