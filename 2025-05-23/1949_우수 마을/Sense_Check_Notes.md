# 🧠 감각 체크 노트 - 셀프 체크

## 내가 DFS를 쓰는 이유를 1문장으로 설명할 수 있는가?

> > "DFS는 트리 구조에서 부모-자식 관계를 정하고, 서브트리 단위의 전이 흐름을 구현하기 위해 사용된다."

내가 현재 이 문제에서 DFS 사용하는 이유는 루트 노드를
어떤 노드로 확정시키고, 그리고 이를 바탕으로 dp를 연산하고자 dfs 처리 과정을 도입하였다.

## dp[node][0], dp[node][1]이 뭘 의미하는지 남에게 설명할 수 있는가?

> > 추가로 dp[node][1]은 자식들을 절대 선택 못하는 상태라는 것도 포함하면 더 탄탄함

여기에서 우리가 문제의 조건에 따라 해당 노드를 우수 마을로 선택하여 노드 내 주민 수를 반영하거나 하지 않거나의 상황을 고려해야 한다.

따라서 우리는 해당 노드가 우수 마을로 선정되었을 경우 dp[node][1]
우수 마을로 선정되지 않았을 경우 dp[node][0]
에 따라 주민 합산 과정에서 다른 절차를 수행하였다.

## 전이식이 왜 그렇게 되는지, 예시 트리에서 손으로 써보면 이해가 되는가?

전이식을 생각해내는 것은 사실 쉽지 않았는데.. 애초에 조건 분기 과정을 생각하지 못했었기 때문에..
하지만, 전이식을 보고 그 우수 마을 선정 유무를 분기로 합산하는 과정
dp[node][0] += max(dp[child][0], dp[child][1])
dp[node][1] += dp[child][0]
이 것에 대해서는 명확한 이해가 가능하였다.

## 왜 루트의 부모는 -1인지 설명 가능한가?

루트는 부모 노드가 없으므로, 해당 노드 리스트에서 어떤 것들과도 일치할 수 없는 임의값인 -1 을 넣은 것으로 이해했다.
따라서
if child == parent:
continue
이렇게 해당 dfs 과정에서 넘어가면서 양방향 그래프 특성상, 자식 노드에서 루프를 돌면서도 부모 노드가 나올 수 있고 이로 인해 무한 루프 처리가 될 수 있기에 이를 방지하고자 넣은 코드를 거치지 않고 처리될 수 있다.

## 내 코드에 graph, dfs, dp가 어떤 구조로 연결되어 있는가를 구조도 없이 설명할 수 있는가?

> > graph는 각 노드가 연결된 이웃 노드를 저장한 트리의 연결 인접 리스트 구조이며, DFS의 반복문에서 이 정보를 기반으로 하위 노드들을 순회하며 DP 전이를 수행한다."

사실 graph는 어떤 라이브러리를 사용한 것이기 떄문에 그냥 아.. graph처럼 관계도에 연결되었겠거니.. 라고 생각하고 있따.
dfs는 해당 graph에서 루트를 선정하고,

우리가 문제의 조건에 따라 우수 마을 선정 및 최대 주민 수를 구하기 위해
루트를 기준으로 순차적인 탐색을 진행할 때 이용하는 함수임을 알고 있다.
따라서 graph 에서 가져온 특정 노드와 연결된 모든 노드들을 graph[node] 을 이용한 반복문에서 가져와서 일일히 처리하는 과정을 거쳐 문제를 해결한다.

dp는 우리가 dfs 처리 과정에서 우수 마을 선정, 미선정에 관한 조건을 분기하고 그에 따른 주민 수를 구하기 위해 사용한 2차원 배열이다.
이 dp는 현 문제상 특정 노드의 포함 유무에 따른 주민 수가 무엇인가? 하는 조건이 2개인 상황에 대한 메모이제이션 처리를 하는 경우라, 2차원 배열을 사용한 것이다.
어쨌든 dfs 처리 과정을 거치며 dp내 주민 수를 기록하며 최대 주민 수를 구하게 된다.

# 추가 학습 - 트리 DP의 DFS 흐름 정복

## 📌 주제: `dfs(child, node)` 이후에 dp 전이가 **언제** 실행되는가?

---

## 🔄 DFS 재귀 흐름 핵심

> `dfs(child, node)`가 먼저 **완전히 끝나야**,  
> 그 아래의 `dp[node][0] += ...`, `dp[node][1] += ...`가 **실행된다.**

---

## ✅ 구조적으로 정리

```python
for child in graph[node]:
    if child == parent:
        continue
    dfs(child, node)  # 먼저 자식 노드를 처리하고
    dp[node][0] += max(dp[child][0], dp[child][1])  # 이후 부모 노드에서 전이
    dp[node][1] += dp[child][0]
```

---

## 🧭 직관적 예시 (루트: 1)

```
        1
       / \
     2     3
```

### 실행 흐름

1. `dfs(1, -1)`
2. 자식 2 → `dfs(2, 1)` → 리프노드 → 복귀
3. `dp[1][0] += max(dp[2][0], dp[2][1])` ← 여기서 연산!
4. 자식 3 → `dfs(3, 1)` → 복귀
5. `dp[1][0] += max(dp[3][0], dp[3][1])`

---

## 🧠 왜 이런 구조인가?

- 트리는 **부모-자식 방향이 없으므로**,  
  DFS를 통해 **서브트리 구조를 명시적으로 확정**해야 함
- 자식의 상태가 먼저 계산되어야 **그걸 기반으로 부모 상태를 계산**할 수 있음

---

## 💡 감각 요약

| 개념      | 설명                                     |
| --------- | ---------------------------------------- |
| DFS       | 자식 → 부모 방향의 값 전이를 위해 사용됨 |
| 전이 시점 | 자식 노드의 DFS가 **완전히 끝난 후**     |
| 구조 감각 | Bottom-Up 방식의 DP 전형                 |
