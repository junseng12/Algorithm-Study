# Problem: 1949_우수 마을
# Date: 2025-05-23
# Language: Python 3

# 조건
# N개의 마을로 이루어진 나라 (마을에는 1부터 N까지 번호가 붙어 있다)
# 마을이 트리(Tree) 구조로 이루어짐
# 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 각 길은 방향성이 없어서 A번 마을에서 B번 마을로 갈 수 있다면 B번 마을에서 A번 마을로 갈 수 있음
# 모든 마을은 연결되어 있음
# 두 마을 사이에 직접 잇는 길이 있을 때, 두 마을이 인접해 있다고 하자
# 다음 세 가지 조건을 만족하면서 N개의 마을 중 몇 개의 마을을 '우수 마을'로 선정하려고 함
# 1. '우수 마을'로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.
# 2. 마을 사이의 충돌을 방지하기 위해서, 만일 두 마을이 인접해 있으면 두 마을을 모두 '우수 마을'로 선정할 수는 없다. 즉 '우수 마을'끼리는 서로 인접해 있을 수 없다.
# 3. 선정되지 못한 마을에 경각심을 불러일으키기 위해서, '우수 마을'로 선정되지 못한 마을은 적어도 하나의 '우수 마을'과는 인접해 있어야 한다.

# 각 마을의 주민 수, 마을 사이의 길에 대한 정보가 주어졌을 때, 주어진 조건을 만족하도록 '우수 마을'을 선정하는 프로그램

# 가정
# 첫째 줄 : 정수 N (1 ≤ N ≤ 10,000) 
# 둘째 줄 : 마을 주민 수를 나타내는 N개의 자연수 ( 각 주민 수는 10,000 이하)
# 셋째 줄~ N-1개 줄: 인접한 두 마을의 번호

# 아이디어 : 
# 트리 구조로 마을이 구성된다고 했는데.. 이를 자료형으로 어떻게 나타낼 것인가?

# 일단 N 개의 마을이 주어졌을 때, 우수 마을을 선정하면 최대 몇 개의 우수 마을을 선정할 수 있는가?
# 분명 최대 우수 마을 선정 시에 인접 마을 관계로 인해, 선정할 수 있는 우수 마을이 정해져 있을 텐데..
# 선정할 수 있는 최대 우수 마을 개수가 아니라도 최대 주민이 나온다면? 이는 어떻게 고려할 것인가?
# 
# dp(i, j) : i 개의 마을 중 j 개 우수 마을에 존재하는 최대의 마을 주민 수
# 

#🧠 Q1. 이 문제에서 “DP 상태”는 어떻게 정의해야 할까?
#💡 Hint 1: 일반 DP처럼 인덱스 순서대로 순회하는 구조가 아님
#트리는 방향이 없는 연결 구조이므로 순회 기준이 필요합니다.

#💡 Hint 2: 어떤 노드를 루트로 삼고
#"이 노드를 선택한 경우 vs 선택하지 않은 경우"를
#각각 나눠서 생각해보면 어떨까요?

# 트리이니까.. 리스트 자료형을 사용하되, 구조체를 이용하여 각 리스트 내 요소에 다음 요소를 가리키는 방식으로 생각하면 되지 않을까?
# 루트 노드는 입력 값에서 확인해 봤을 때, 어떻게 선정해야 할 지 잘 감이 안 온다..

# 답 : 트리는 어디서 시작하든 상관없음 (일반적으로 1번 노드를 루트로 시작)
# 단, 부모 → 자식의 방향을 추론하기 위해 dfs(node, parent) 구조 사용

# 이 노드를 우수마을로 선택한 경우, 선택하지 않은 경우를.. 고려하면 배낭 문제랑 비슷한 접근 인 것 같은ㄴ데.. 아직 감이 안ㅇ ㅗㄴ다.
#dp[node][0] = 이 노드를 '선택하지 않았을 때'의 최대 주민 수
#dp[node][1] = 이 노드를 '선택했을 때'의 최대 주민 수

# node 선택 기준에 따른 조건 분기
# dp[node][0] += max(dp[child][1], dp[child][0])
# dp[node][1] += dp[child][0]


#🧠 Q2. 최종 정답은 어떻게 계산해야 할까?
#또, 그 위치의 dp 값이 의미하는 바는 무엇인가?

#🔍 먼저 구조를 다시 복기해보자
#우리는 DFS를 통해 서브트리 기준으로 dp 값을 누적합니다.
#이때 모든 전이 결과는 루트 노드로 올라옵니다.
#루트 노드는 트리 전체의 "최적 상태"를 담고 있는 노드입니다.

# 따라서 최종 정답은 루트 노드의 [0], [1] 중 큰 값이다.

import sys
from collections import defaultdict
input = sys.stdin.readline

sys.setrecursionlimit(1000000)


N = int(input())
graph = defaultdict(list)


# 주민 수 배열 생성 및 0 인덱스에 0을 추가하여 노드 인덱스와 동일하게 맞추기
population = list(map(int, input().split()))

population.insert(0, -1)

# 양방향 간선 연결 (트리이므로 방향 없음)
for _ in range(N-1):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)
    
dp = [[0, 0] for _ in range(N + 1)]
    
def dfs(node, parent):
    dp[node][0] = 0
    dp[node][1] = population[node]

    for child in graph[node]:
        if child == parent:
            continue
        dfs(child, node)
        dp[node][0] += max(dp[child][0], dp[child][1])
        dp[node][1] += dp[child][0]

dfs(1, -1)


print(max(dp[1][0], dp[1][1]))