# 💬 Reflection: 팰린드롬? (BOJ 10942)

## 🧠 1. 접근 과정 요약

- 처음에는 슬라이싱으로 직접 비교하는 구조를 고려
- 질의가 많아질수록 시간 초과 발생할 것을 우려
- 팰린드롬 정의에 따라 dp[i][j]를 미리 채우는 방식으로 접근
- Top-down 재귀 + 메모이제이션으로 구현해 정답 통과

## 🔄 2. 시행착오 및 사고 흐름

- 처음에 dp 배열을 1차원으로 잘못 구성
- 배열 이름 혼용 (arr, M) 문제 발생
- `dp[i][j] != -1` 조건으로 중복 재귀 방지
- Bottom-Up 방식도 함께 이해하고 비교함

## ✅ 3. 최종 구현 포인트

- Top-Down 재귀 구현
- `dp[i][j] = 1 if arr[i] == arr[j] and isPalindrome(i+1, j-1)`
- `dp[i][i] = 1`, `dp[i][i+1] = 1 if arr[i] == arr[i+1]`

## 💡 4. 보완 아이디어

- Bottom-Up 방식은 반복문으로 모든 dp[i][j] 채움 → 속도 향상
- 팰린드롬 유형 문제를 한꺼번에 묶어서 풀어보면 감각이 생김

## 🔁 5. 복습 포인트

- 팰린드롬의 전이 조건 기억하기
- 점화식이 반드시 정의에서 출발해야 함
- Bottom-Up vs Top-Down 비교 감각 익히기

## ✍️ 6. 한 줄 소감

> "팰린드롬은 구조를 먼저 정복하고 나면, 질의가 아무리 많아도 두렵지 않다."
