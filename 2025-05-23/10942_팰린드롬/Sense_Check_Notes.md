# 🧠 감각 체크 노트: 팰린드롬 구간 판별 - Bottom-Up DP 구조

## ✅ 목표

- 모든 `dp[i][j]`에 대해 `S[i] ~ S[j]` 구간이 팰린드롬인지 여부를 미리 전처리해둔다.

---

## 📌 핵심 정의

```python
dp[i][j] = 1  # S[i] ~ S[j]가 팰린드롬이면
dp[i][j] = 0  # 아니라면
```

---

## 🔁 Bottom-Up 전이 흐름

```python
for length in range(2, N+1):  # 길이 2부터 N까지
    for start in range(1, N - length + 2):
        end = start + length - 1
        if S[start] == S[end]:
            if length == 2:
                dp[start][end] = 1
            elif dp[start+1][end-1] == 1:
                dp[start][end] = 1
```

---

## ✨ Base Case 초기화

```python
for i in range(1, N+1):
    dp[i][i] = 1  # 길이 1은 항상 팰린드롬

for i in range(1, N):
    if S[i] == S[i+1]:
        dp[i][i+1] = 1  # 길이 2인 경우 양 끝만 비교
```

---

## 🤔 Q: 왜 `length = 2`부터 시작하나?

### A:

- 팰린드롬 전이식은 `dp[i+1][j-1]`을 필요로 함
- 길이 1은 자기 자신이므로 `dp[i][i] = 1`로 **미리 처리**
- 길이 2는 예외 처리로 바로 비교
- 따라서 **점화식 기반 확장은 길이 3 이상부터 가능** → `length = 2`부터 시작

---

## 💬 구현 방식 선택 팁

| 방식            | 장점                 | 단점                  |
| --------------- | -------------------- | --------------------- |
| Bottom-Up       | 질의 O(1), 매우 빠름 | 코드 길어짐           |
| Top-Down (재귀) | 구현 직관적          | 느림 (중복 계산 위험) |

---

## 🧠 감각 요약

| 개념      | 설명                                            |
| --------- | ----------------------------------------------- |
| 전이 조건 | `S[i] == S[j] and dp[i+1][j-1] == 1`            |
| 전처리    | O(N²)로 미리 채워두고 → 질의는 O(1)             |
| 핵심 감각 | 구간 기반 팰린드롬은 DP 상태 누적으로 판별 가능 |

---
