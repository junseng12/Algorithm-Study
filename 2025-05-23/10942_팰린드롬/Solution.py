# Problem: 10942_팰린드롬?
# Date: 2025-05-23
# Language: Python 3

# 조건
#먼저, 홍준이는 자연수 N개를 칠판에 적는다. 그 다음, 명우에게 질문을 총 M번 한다.
# 각 질문은 두 정수 S와 E(1 ≤ S ≤ E ≤ N)로 나타낼 수 있음
# S번째 수부터 E번째 까지 수가 팰린드롬을 이루는지를 물어보며, 명우는 각 질문에 대해 팰린드롬이다 or 아니다를 말해야 함

# 자연수 N개와 질문 M개가 모두 주어졌을 때, 명우의 대답을 구하는 프로그램

# 가정
# 첫째 줄: 수열의 크기 N (1 ≤ N ≤ 2,000)
# 둘째 줄: 홍준이가 칠판에 적은 수 N개가 순서대로 주어짐 (100,000보다 작거나 같은 자연수)
# 셋째 줄: 홍준이가 한 질문의 개수 M (1 ≤ M ≤ 1,000,000)
# 넷째 줄부터 M개의 줄: 홍준이가 명우에게 한 질문 (S, E) 쌍

# 아이디어 : 
# 펠린드롬이 특정 범위 인덱스 내 요소들이 대칭을 이루는지 확인하는 것이니까..
# 특정 범위 인덱스가 제시되면... 그 인덱스 범위 만큼 원본에서 슬라이싱해서.. reverse 값이 원본이랑 똑같은지 확인하면 되지 않나?
# 느낌이 딱봐도 이렇게 하면 간단한데.. 시간 초과날 것 같은 느낌...

#🧠 Q1. 어떤 상태를 기억해두면 팰린드롬 여부를 빠르게 판별할 수 있을까?
#💡 Hint 1: 수열의 특정 구간이 팰린드롬인지 빠르게 확인하려면,
#매번 슬라이싱해서 비교하면 TLE가 발생합니다.

#💡 Hint 2: 팰린드롬의 정의를 앞-뒤 인덱스 관계로 나타내고,
#이를 DP로 저장할 수 있을까요?

# 배열을 한번 입력 받았을 때 모두 싹 돌면서... 팰린드롬 유무 파악하고 기억해놓는다면.. 그다음 요청부터는 읽어서 결과만 내면 되니까..
# 같은 원소값이 들어가는 경우에 그 위치를 인덱스 쌍 형태로 기억해놓는다면?  인덱스 1번쨰와 3번째에 같은 원소값이 들어가면 (1,3) 느낌으로 저장해 놓는 것
# 이를 바탕으로 특정 인덱스 범위 내 해당 기억된 위치들이 반복되는지 확인한다면 가능하지 않을까 싶음..
# 어떻게 해야할지는 잘 모르겠는데..
# dp[i][j] = i 인덱스와 j 인덱스 범위 내 팰린드롬인지 유무 0 or 1
# 이렇게 정의하면 되지 않을까?
# 어떻게 팰린드롬 확인할 지는 생각이 아직 나지 않음

# 답 : 전이적 아이디어
# S[i] == S[j]이고, S[i+1] == S[j-1]도 팰린드롬이면.. S[i] ~ S[j]도 팰린드롬이다..
# dp[i][j] is 팰린드롬 
# if dp[i+1][j-1] = 1
# and S[i] == S[j]
 
import sys
from collections import defaultdict
input = sys.stdin.readline

sys.setrecursionlimit(1000000)

N = int(input())

# M을 N+1 사이즈로 설정하고 0 인덱스에는 쓰레기값 집어넣음(-1)
arr = list(map(int, input().split()))
arr.insert(0, -1)

dp = [[-1 for col in range(N+1)] for row in range(N+1)]

def isPalindrome(i , j):
    #정의가 이미 된 경우에 바로 return
    if dp[i][j] != -1:
        return dp[i][j] 
    # 동일한 인덱스 값을 받은 경우(동일 원소 가르킴)
    if i == j :
        dp[i][j] = 1
    # 인덱스 범위가 1개 차이인 경우(각 원소만 비교하면 됨)
    elif i + 1 == j :
        if(arr[i] == arr[j]):
            dp[i][j] = 1
        else:
            dp[i][j] = 0
    # 인덱스 범위가 1보다 큰 경우(인덱스 범위 내 원소가 많을 경우)
    else :
        if(arr[i] == arr[j]) and (isPalindrome(i+1, j-1)):
            dp[i][j] = 1
        else :
            dp[i][j] = 0
    return dp[i][j]



M = int(input())

for _ in range(M):
    i, j = map(int, input().split())
    print(isPalindrome(i,j))