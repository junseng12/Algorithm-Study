# 💬 Reflection: 가장 긴 증가하는 부분 수열 (BOJ 11053)

## 🧠 1. 접근 과정 요약

- 처음에는 점화식 구조가 잘 잡히지 않았지만, “수열의 흐름을 어떻게 기억해야 하는가”에 집중했다
- dp[i]를 A[i]를 마지막으로 갖는 증가 수열의 최장 길이로 정의하면서 문제 구조가 명확해졌다
- 이중 반복문을 통해 모든 이전 값을 비교하고 조건을 만족할 때만 길이를 갱신

## 🔄 2. 시행착오 및 사고 흐름

- 처음에는 `dp[i+1]`을 참조하는 방식으로 생각했지만, 그 방식은 수열의 흐름상 역방향으로 맞지 않다는 점을 깨달음
- `j < i` 조건의 의미와 증가 조건인 `A[j] < A[i]`가 핵심임을 점차 파악

## ✅ 3. 최종 구현 포인트

- 초기화: `dp[i] = 1` (자기 자신 하나만 포함하는 경우)
- 점화식: `dp[i] = max(dp[i], dp[j] + 1)` for all `j < i and A[j] < A[i]`
- 최종 정답: `max(dp)`로 전체 중 가장 긴 수열 길이 반환

## 💡 4. 보완 아이디어

- 이분 탐색을 활용한 O(N log N) 방식도 학습해보면 좋을 듯 (binary search + patience sorting)
- 실제 문제에선 LIS를 직접 구성하는 방법도 필요할 수 있음

## 🔁 5. 복습 포인트

- 증가하는 수열은 항상 “이전 값 중 나보다 작고, 수열 길이가 가장 긴 것”에서 전이됨
- 점화식이 자연스럽게 수열의 흐름을 따르도록 설계해야 한다

## ✍️ 6. 한 줄 소감

> “증가하는 흐름은 생각보다 조용히 자란다 — 비교와 누적이 만들어내는 성장의 알고리즘.”
