# 💬 Reflection: 정수 삼각형 (BOJ 1932)

## 🧠 1. 접근 과정 요약

- 문제를 보고 곧바로 `dp[i][j] = 현재 위치까지 도달한 최대합`으로 정의
- 각 위치는 두 가지 경로(`dp[i-1][j-1]`, `dp[i-1][j]`)로부터 올 수 있으므로,
  → `dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + cost[i][j]`로 점화식 유도
- 가장자리는 한 쪽 방향만 존재하므로 별도 조건 분기 필요

## 🔄 2. 시행착오 및 사고 흐름

- 구현 시작 전에 DP 전이 구조와 경계 조건을 명확히 머릿속에 정리
- `copy.deepcopy()`를 사용했지만, 공간 최적화가 가능하다는 점도 피드백을 통해 학습

## ✅ 3. 최종 구현 포인트

- `dp[0][0] = cost[0][0]`으로 초기화
- `dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + cost[i][j]`
- 경계 처리: `j == 0`, `j == i`
- 최종 출력: `max(dp[N-1])`

## 💡 4. 보완 아이디어

- 공간 최적화를 위해 `dp` 없이 `cost` 배열을 직접 갱신 가능
- DFS + memoization 방식으로도 풀 수 있으나, Bottom-Up DP가 더 직관적이고 효율적

## 🔁 5. 복습 포인트

- **2차원 DP 구조는 상태 정의가 명확할수록 코드가 자연스럽다**
- 테두리 조건을 따로 분기 처리하지 않으면 IndexError나 논리 오류가 발생할 수 있음

## ✍️ 6. 한 줄 소감

> “최대가 되는 경로는 우연히 만들어지지 않는다 — 선택과 누적의 결과다.”
