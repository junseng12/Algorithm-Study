# 💬 Reflection: 숨바꼭질 2 (BOJ 12851)

## 🧠 1. 접근 과정 요약

- BFS로 최단 시간 탐색이 가능하다는 점을 우선 떠올림
- 문제는 단순 visited가 아니라 “동일 시간에 도달하는 모든 경로 수”도 누적해야 했음
- visited는 도달 시간, count는 도달 방법 수를 기록하는 방식으로 분리

## 🔄 2. 시행착오 및 사고 흐름

- visited[next] >= visited[now] + 1로 조건을 설정해 중복 누적 발생 → 잘못된 수 누적
- visited[next] == visited[now] + 1일 때만 누적하는 조건을 이해하고 고정함
- visited 초기값을 float('inf')로 설정해 미방문 상태 구분

## ✅ 3. 최종 구현 포인트

- `visited[i] = t`: i에 처음 도달한 시간 t
- `count[i]`: i에 도달한 경우의 수 (최소 시간 기준)
- BFS 큐에서 나온 순서 자체가 최소 시간 보장

## 💡 4. 보완 아이디어

- visited를 2차원으로 확장할 필요 없이 1차원으로도 충분
- BFS 큐에 이미 들어간 위치는 같은 시간이라면 다시 append하지 않음

## 🔁 5. 복습 포인트

- 최단 시간은 BFS가 보장한다
- count 누적은 visited[now] + 1 == visited[next]일 때만 수행
- visited 초기화는 반드시 float('inf')로, 0이 아님

## ✍️ 6. 한 줄 소감

> “최단 거리 탐색과 경우의 수 누적은 BFS의 정석을 가장 잘 보여준다.”
