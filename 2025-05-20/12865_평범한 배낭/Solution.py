# Problem: 12865_평범한 배낭
# Date: 2025-05-20
# Language: Python 3

# 조건
# N개의 물건이 있으며, 각 물건은 무게 W와 가치 V를 가짐
# 최대 K만큼의 무게만을 넣을 수 있는 배낭에 가질 수 있는 가치의 최대값은 얼마인지 구하라

# 가정
# 첫 줄 : 물품의 수 N(1 ≤ N ≤ 100), 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)
# 두번째 ~(총 N개의 줄) : 각 물건의 무게 W(1 ≤ W ≤ 100,000), 해당 물건의 가치 V(0 ≤ V ≤ 1,000) 

# 아이디어 : 
#무게 한도 K를 넘지 않도록 물건을 담되, 가치의 합이 최대가 되도록 하라.
#가치 합이 최대가 되려면.. 우선적으로 가장 가치가 큰 물건부터 넣자.
#물론, 가치가 가장 큰 것이 들어가지 않은 상황에서 가치 최대값 나올 수 있으니까.. 
# 이 문제는 각 무게도 고려하면서 최대의 가치를 얻어야 하기 떄문에, 1차원 배열로 정의하긴 힘들고 2차원 배열로 정의하다
# dp[i][w] = w 만큼의 무게 한도에서의 i번쨰 물건을 고려한 가치의 최댓값

#🧠 Q1. 이 문제에서 “상태”는 무엇으로 정의해야 할까?
#💡 Hint 1: 최적화 문제에서 dp[i]는 보통 **“최대값 or 최소값”**을 의미합니다.
#여기서는 “최대 가치”를 저장하려면 어떤 상태를 추적해야 할까요?

# 일단 우선적으로 모든 과정에서 if 배낭들의 합 <= K 이어야 함
# 그 다음 각 V에 대한 업데이트를 진행하면서 ..
# dp[i][w] = w 만큼의 무게 한도에서의 i번쨰 물건을 고려한 가치의 최댓값
# dp[i][w] = max(dp[i-1][w-weight[i]] + value[i], dp[i-1][w])

#💡 Hint 2: 한 물건을 넣거나 안 넣는 선택이 있고, 무게 제한이 있습니다.
#그럼 상태를 [현재 물건 인덱스][남은 무게]로 정의할 수 있을까요?

# 아. weight 뺼 때, 이게 0이 되면 안되니까..
# if w < weight 일 떄는 
# 그냥 무조건 dp[i-1][w]로 못넣는 경우로 생각해야함

#🧠 Q2. "무거운 물건부터 넣는 게 더 효율적인가?"
#즉, for i in range(N-1, -1, -1) ← 이렇게 처리하는 게 좋은가?

#🎯 정답 먼저 말하자면:
#무거운 물건부터 넣는다고 해서 DP의 효율이 달라지지 않습니다.
#Knapsack 문제에서는 물건을 어떤 순서로 보느냐는 중요하지 않고,
#각 물건을 넣느냐 마느냐의 분기와 상태 갱신만이 중요합니다.

#✅ 이유 1: 모든 물건은 "선택 or 미선택"만 고려됨
#i번째 물건을 선택할 수 있다면,
#dp[w] = max(dp[w], dp[w - weight[i]] + value[i])

#여기서 무게 순서가 아니라 가능한 무게를 기준으로 분기가 발생하기 때문에 → 물건을 어떤 순서로 보든 결과는 같음

N, K = map(int, input().split())

weight = []
value = []

for _ in range(N):
  w, v = map(int, input().split())
  weight.append(w)
  value.append(v)
  
dp = [[0 for col in range(K+1)] for row in range(N+1)]

w = K  
  
for i in range(1, N+1):
  #메모이제이션 범위 확인하는 것
  for w in range(0, K+1):
    #weight에서 i번째 물건은 weight[i-1]
    if weight[i-1] > w:
      dp[i][w] = dp[i-1][w]
    else:
      dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i-1]] + value[i-1] )
    
  
  
print(dp[N][K])