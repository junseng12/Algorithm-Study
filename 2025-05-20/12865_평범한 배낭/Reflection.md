# 💬 Reflection: 평범한 배낭 (BOJ 12865)

## 🧠 1. 접근 과정 요약

- 처음에는 가치가 큰 물건을 우선적으로 넣으면 될 것 같았지만,
  → 그게 항상 최적은 아니라는 점을 인지
- 각 물건의 선택 여부에 따라 가능한 모든 무게를 탐색하는 구조가 필요
- 결국 **DP 상태 정의**가 핵심임을 파악함:
  → `dp[i][w] = i번째 물건까지 고려했을 때, 무게 w일 때 최대 가치`

## 🔄 2. 시행착오 및 사고 흐름

- 초기 구현에서 `weight[i]`와 `value[i]` 사용 시 인덱스 오류 발생
  → 리스트는 0-based, DP는 1-based 인덱스라 `i-1`로 수정
- `무거운 물건을 먼저 고려해야 효율적인가?`에 대한 의문이 있었으나
  → DP에서는 물건 순서는 중요하지 않음, 상태 갱신 흐름이 본질

## ✅ 3. 최종 구현 포인트

- 2차원 배열로 구현 (`dp[N+1][K+1]`)
- `dp[i][w] = dp[i-1][w]` (물건을 선택하지 않음)
- `dp[i][w] = dp[i-1][w - weight[i-1]] + value[i-1]` (선택 시)
- 점화식이 정확히 작동하도록 인덱스 통일 중요

## 💡 4. 보완 아이디어

- 이후에 1차원 DP 최적화도 시도할 수 있음
  → 뒤에서부터 갱신하는 이유와 패턴을 복습
- 시간과 메모리 측면에서 최적화 아이디어 시각화 필요

## 🔁 5. 복습 포인트

- 1-based vs 0-based indexing 실수 방지
- 상태 정의가 문제 해결의 핵심 (dp[i][w]의 의미는?)
- 무게 갱신 방향의 중요성은 1차원에서 더 큰 역할

## ✍️ 6. 한 줄 소감

> “배낭 문제의 본질은 물건의 순서가 아니라 상태의 정의에 있다.”
