# 💬 Reflection: 플로이드 (BOJ 11404)

## 🧠 1. 접근 과정 요약

- 도시 간 최단 거리 계산 → 모든 정점 쌍 필요
- BFS/다익스트라는 단일 출발점 기준 → 부적합
- 플로이드 워셜 알고리즘이 모든 정점 쌍에 적합함을 인지
- `dp[i][j] = i에서 j까지 가는 최소 비용`으로 정의
- 3중 반복문으로 경유지를 하나씩 잡고, 모든 출발-도착 조합에 대해 전이 수행

## 🔄 2. 시행착오 및 사고 흐름

- 중복 노선이 있을 수 있어 입력 시 `min(dp[i][j], cost)`로 처리 필요
- `dp[i][j] = INF`로 초기화하되, `i == j`면 `dp[i][j] = 0`
- 출력 시 INF인 곳은 0으로 변환하지 않아도 되는 점 고려

## ✅ 3. 최종 구현 포인트

- `dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])` 전이식
- 3중 for문 순서 반드시 `k → i → j` 순서로 유지
- 경유지 기준의 상태 전이가 핵심임을 완벽히 체감함

## 💡 4. 보완 아이디어

- 경로까지 복원하려면 추가적으로 path[i][j] 배열이 필요 (여기선 생략)
- 입력 범위가 작다면 다익스트라 N번보다 이 방식이 간단하고 실용적임

## 🔁 5. 복습 포인트

- 전형적인 플로이드 워셜 문제 유형
- 초기화 감각 + 전이 순서 감각을 반복적으로 체화할 것

## ✍️ 6. 한 줄 소감

> “모든 정점 쌍 최단 거리를 가장 직관적인 방식으로 푸는 알고리즘이 바로 플로이드 워셜이다.”
