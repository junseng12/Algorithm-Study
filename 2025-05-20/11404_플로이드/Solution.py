# Problem: 11404_플로이드 
# Date: 2025-05-20
# Language: Python 3

# 조건
#n개의 도시
#한 도시에서 출발하여 다른 도시에 도착하는 m개의 버스 있음
#버스는 한 번 사용할 때 필요한 비용 있음
#모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값 구하라

# 가정
#첫째 줄: 도시의 개수 n (2 ≤ n ≤ 100)
#둘째 줄: 버스의 개수 m (1 ≤ m ≤ 100,000)
#셋째 줄부터 m+2줄 : 버스의 정보
# 버스의 정보 구성 : (a, b, c) 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c (c <= 100,000 인 자연수)
 

# 아이디어 : 
# 가는 경로, 그 경로에 따른 비용 2가지를 기록해야 할 필요 있는 것 같음
# A-> C로 가는 경로를 A-> B, B-> C로 가는 경로로 나누어 계산할 수도 있기 때문임
# 그런데 가는 위에 처럼 가는 경로를 나누어 계산할 수 있기 때문에 혹시 가는 경로까지 기억해야 하나? 싶은데.. 문제에서는 사실 굳이 필요 없긴 함.
# 따라서 2차원 배열 dp[i][j] = i 지역에서 j지역으로 가는데 필요한 최소 비용 c
# dp[i][j] = min(dp[i][k] + dp[k][j] + cost[i][k] + cost[k][j], cost[i][j]) 약간 요런 느낌으로 구성하면 안되려나?
# >> 중복된 불필요한 식이 포함되어 있음 
# 이미 dp[i][k]에는 i → k의 최단 거리가 저장되어 있고,
# dp[k][j]도 마찬가지로 k → j까지의 누적된 최단 거리임
# >>>>> dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]) [플로이드 워셜 알고리즘]

# Q1.을 보니까 왠지 단일 출발점 아니니까, 이 각 출발지점에 따른 경우도 고려해야 함을 말하고 있고.. 차원의 증가
# 시간 제한이 여유롭다고 말하는 것을 보니까... 전수조사를 진행해도 될 것 같다는 느낌이 듦...
# 이럴 때 어떤 알고리즘을 진행할 지는.. 잘 감이 안 옮 이전에 한번 경험했던 BFS로 해야 하나? 근데 이거는 각 level 마다 최단 거리로 보장되어 있을 경우고 여기에서는 cost 요소가 더해지니까... 다르긴 한데
# 잘 모르겠음



#🧠 Q1. 이 문제는 어떤 알고리즘을 사용해야 할까?
#💡 Hint 1: 모든 정점 쌍 간 최단 거리 =
#한 정점에서 출발해서 모든 정점까지가 아님 → 단일 출발점 X

#💡 Hint 2: 시간 제한은 O(N³)도 허용할 만큼 여유 있음
#어떤 알고리즘이 이에 최적화되어 있을까요?

#🧠 Q2. dp[i][j] 값을 어떻게 초기화해야 할까?
#플로이드 워셜에서는 **모든 정점 쌍 (i, j)**에 대해
#최단 경로를 갱신해야 하므로 초기값 세팅이 매우 중요합니다.

# 이거 어디서 봤었는데.. 최단 경로로 갱신하려고 하면 최소 첫 입력값은 항상 업데이트 되어야 하므로, 무한 값을 넣어야 함
# 그리고 자기 자신으로 가는 값은 0 으로 초기화 해야 하며, 
# 이를 제외한 i -> j 로 가는 값은 둘러보면서 cost[i][j] 값으로 초기화 하면 되지 않을까 싶음


#✅ 핵심 조건 3가지
# dp[i][i] = 0 → 자기 자신에게 가는 비용은 0
# dp[i][j] = 주어진 경로 비용 c → 입력으로 주어진 간선 정보로 초기화
# dp[i][j] = ∞ (즉, 갈 수 없음) → 경로가 없다면 매우 큰 값으로 설정

N = int(input())
M = int(input())

INF = int(1e9)  # 무한대 정의

# 1-based 인덱스 사용 (1 부터 N 까지)
dp = [[INF] * (N+1) for _ in range(N+1)]

# 자기 자신에게 가는 비용 0
for i in range(1, N+1):
    dp[i][i] = 0

# 버스 비용 입력 처리
for _ in range(M):
  i, j, c = map(int, input().split())
  dp[i][j] = min(dp[i][j], c)
    
    
# "모든 정점 쌍 간의 거리" 를 "모든 경유지"를 통해 갱신해야 함
# -> 경유지 k를 거쳐서 i → j로 가는 모든 가능한 경로를 시도해보는 구조
for k in range(1, N+1): # 경유지
  for i in range(1, N+1): # 출발지
    for j in range(1, N+1): # 도착지
      dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
      

# 각 i 지점에서 j로 향하는 최소 거리 출력
for i in range(1, N+1):
  for j in range(1, N+1):
    if(dp[i][j] == INF):
      print(0, end=' ')
    else:
      print(dp[i][j], end=' ')
  print()