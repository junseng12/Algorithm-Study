# 💬 Reflection: 사회망 서비스 (BOJ 2533)

## 🧠 1. 접근 과정 요약

- 트리라는 조건을 보고 처음부터 DFS 기반 구조로 접근
- 자식 노드의 상태를 바탕으로 부모 노드의 선택 가능 여부가 결정되므로,
  **Bottom-up 방식의 DP 설계가 적합하다고 판단**
- 얼리 어답터 조건(이웃이 반드시 얼리 어답터)을 구조화해서
  "선택 / 비선택" 상태를 명시적으로 나눔

## 🔄 2. 시행착오 및 사고 흐름

- 처음에는 단순히 visited 배열 없이 재귀만 사용하다가 **중복 호출** 발생
- DP[node][0]과 DP[node][1] 상태를 명확히 분리하면서
  **하위 노드 처리 전략**을 정리하게 됨
- 특히 "내가 얼리 어답터면 자식은 아무거나 가능",  
  "내가 비-얼리어답터면 자식은 반드시 얼리 어답터"라는 조건을  
  **구현 전 사고 흐름에서 먼저 정리**한 것이 효과적이었음

## ✅ 3. 최종 구현 포인트

```python
def dfs(node, parent):
    dp[node][0] = 0
    dp[node][1] = 1
    for child in graph[node]:
        if child != parent:
            dfs(child, node)
            dp[node][0] += dp[child][1]
            dp[node][1] += min(dp[child][0], dp[child][1])
```

- 루트 노드(보통 1번) 기준으로 min(dp[1][0], dp[1][1]) 출력

## 🚩 4. 시간/공간 복잡도

- 시간 복잡도: O(N) (트리 전체 DFS 1회)

- 공간 복잡도: O(N) (dp 테이블, 그래프 인접 리스트)
