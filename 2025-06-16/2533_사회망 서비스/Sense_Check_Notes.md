# 📌 Sense Check Notes - BOJ 2533

## 1️⃣ 이 문제는 왜 DFS + DP 구조로 접근해야 했는가?

- 트리는 사이클이 없기 때문에 **자식 → 부모 방향으로만 누적**이 가능
- 자식 상태를 모두 계산한 후 → 부모가 최적의 선택을 할 수 있음
- 따라서 Bottom-up 방식의 DFS + DP 구조가 최적

## 2️⃣ 얼리 어답터 조건은 어떻게 해석해야 했는가?

- "내가 비-얼리어답터면, 모든 이웃(자식)은 반드시 얼리 어답터여야 함"
- "내가 얼리 어답터면, 자식은 선택 여부 자유"
  → 이 규칙이 상태 분기의 기준이 됨

## 3️⃣ DP 테이블은 어떻게 정의했는가?

- DP[node][0]: node가 **비-얼리어답터일 때** 전체 최소 얼리 어답터 수
- DP[node][1]: node가 **얼리 어답터일 때** 전체 최소 수

## 4️⃣ DP 상태 전이식은 어떤 의미였나?

```python
dp[node][0] += dp[child][1]            # 내가 비-얼리어답터 → 자식은 무조건 얼리어답터
dp[node][1] += min(dp[child][0], dp[child][1])  # 내가 얼리어답터 → 자식은 자유
```

## 5️⃣ 핵심 교훈

- 트리 DP는 "상태 분기"를 명확히 하며 하위 상태를 누적하는 것이 핵심

- 이 문제를 통해 트리 DP에서의 전형적인 패턴(선택/비선택)을 체득함

- 이후 Merkle Tree처럼 트리 상태를 추적하고 누적하는 방식에도 적용 가능
