# Problem: 1949_ìš°ìˆ˜ ë§ˆì„
# Date: 2025-05-23
# Language: Python 3

# ì¡°ê±´
# G(V, E)ì—ì„œ ì •ì ì˜ ë¶€ë¶„ ì§‘í•© Sì— ì†í•œ ëª¨ë“  ì •ì ìŒì´ ì„œë¡œ ì¸ì ‘í•˜ì§€ ì•Šìœ¼ë©´ (ì •ì ìŒì„ ìž‡ëŠ” ê°„ì„ ì´ ì—†ìœ¼ë©´) Së¥¼ ë…ë¦½ ì§‘í•©(independent set)ì´ë¼ê³  í•¨
# ë…ë¦½ ì§‘í•©ì˜ í¬ê¸° : (ì •ì ì— ê°€ì¤‘ì¹˜ê°€ ì£¼ì–´ì ¸ ìžˆì§€ ì•Šì„ ê²½ìš°) ë…ë¦½ ì§‘í•©ì— ì†í•œ ì •ì ì˜ ìˆ˜
# (ì •ì ì— ê°€ì¤‘ì¹˜ê°€ ì£¼ì–´ì ¸ ìžˆëŠ” ê²½ìš°) ë…ë¦½ ì§‘í•©ì— ì†í•œ ì •ì ì˜ ê°€ì¤‘ì¹˜ì˜ í•©
# ë…ë¦½ ì§‘í•©ì´ ê³µì§‘í•©ì¼ ë•Œ ê·¸ í¬ê¸°ëŠ” 0ì´ë¼ê³  í•˜ìž. 
# ìµœëŒ€ ë…ë¦½ ì§‘í•©: í¬ê¸°ê°€ ìµœëŒ€ì¸ ë…ë¦½ ì§‘í•© 
# íŠ¸ë¦¬(ì—°ê²°ë˜ì–´ ìžˆê³  ì‚¬ì´í´ì´ ì—†ëŠ” ê·¸ëž˜í”„)ì™€ ê° ì •ì ì˜ ê°€ì¤‘ì¹˜ê°€ ì–‘ì˜ ì •ìˆ˜ë¡œ ì£¼ì–´ì ¸ ìžˆì„ ë•Œ, ìµœëŒ€ ë…ë¦½ ì§‘í•©ì„ êµ¬í•˜ë¼

# ê°€ì •
# ì²«ì§¸ ì¤„: íŠ¸ë¦¬ì˜ ì •ì ì˜ ìˆ˜ n (nì€ 10,000ì´í•˜ì¸ ì–‘ì˜ ì •ìˆ˜)
#  1ë¶€í„° nì‚¬ì´ì˜ ì •ìˆ˜ê°€ íŠ¸ë¦¬ì˜ ì •ì ì´ë¼ê³  ê°€ì •
# ë‘˜ì§¸ ì¤„: nê°œì˜ ì •ìˆ˜ w1, w2, ..., wnì´ ì£¼ì–´ì§ (wi: ì •ì  iì˜ ê°€ì¤‘ì¹˜(1 â‰¤ i â‰¤ n), ê°€ì¤‘ì¹˜ë“¤ì˜ ê°’ì€ 10,000ì„ ë„˜ì§€ ì•ŠëŠ” ìžì—°ìˆ˜)
# ì…‹ì§¸ ì¤„~ ë§ˆì§€ë§‰ ì¤„: ê°„ì„ ì˜ ë¦¬ìŠ¤íŠ¸(í•œ ì¤„ì— í•˜ë‚˜ì˜ ê°„ì„ )

# ì•„ì´ë””ì–´ : 
# (i, j) ìŒì„ ìž…ë ¥ë°›ì•˜ì„ ë•Œ, ê° (i, j) ìŒì„ ë¹„êµí•˜ë©´ì„œ ì§ì ‘ì ìœ¼ë¡œ ì—°ê²°ë˜ì§€ ì•Šì€ Vertexì˜ ì§‘í•©ì„ êµ¬í•¨(ë…ë¦½ ì§‘í•©)
# í•´ë‹¹ ì§‘í•©ì— ë”°ë¥¸ Vertex ë³„ ê°€ì¤‘ì¹˜(wi) ë„ í•©í•˜ì—¬ ìµœëŒ€ ë…ë¦½ ì§‘í•© ì„ ì •í•´ì•¼ í•¨

# ê° vertes ì§‘í•©ì„ êµ¬í•œ ë‹¤ìŒì—, ìµœëŒ€ ë…ë¦½ ì§‘í•©ì— ëŒ€í•œ í•©ì„ êµ¬í•˜ë©´ì„œ ë™ì‹œì— í•´ë‹¹ ë…ë¦½ ì§‘í•©ì˜ êµ¬ì„± ìš”ì†Œë„ êµ¬í•´ì•¼í•¨.
# 2ê°€ì§€ ì¡°ê±´ ì¶©ì¡± >> 2ì°¨ì› ë°°ì—´ í™œìš©
# ë°‘ì— ê³ ë¯¼í•´ë³´ë‹ˆê¹Œ ì¼ë°˜ì ì¸ dp[i][j] í˜•íƒœë¡œëŠ” ë‚˜íƒ€ë‚¼ ìˆ˜ ì—†ì„ ê²ƒ ê°™ìŒ..
# ë”°ë¼ì„œ 2ê°€ì§€ ì¡°ê±´ì„ í‘œí˜„í•˜ê¸´ í•˜ëŠ”ë°.. ê·¸ ë­ì•¼ 

# ë…ë¦½ ì§‘í•©ì„ êµ¬ì„±í•  ë•Œ, íŠ¹ì • í•˜ë‚˜ ë…¸ë“œë¥¼ ì„ íƒí•˜ê²Œ ë˜ë©´, ê·¸ê²ƒê³¼ ì§ì ‘ ì¸ì ‘í•œ ë…¸ë“œëŠ” ì„ íƒí•  ìˆ˜ ì—†ìŒ..
# ë”°ë¼ì„œ í•˜ë‚˜ ë…¸ë“œê°€ ë…ë¦½ì§‘í•©ì— í¬í•¨ë˜ëŠ”ì§€ ì•„ë‹Œì§€ ì„ ì •í•˜ë©´, ê·¸ê²ƒì— ë”°ë¥¸ ë‹¤ë¥¸ ë…¸ë“œ ì„ íƒ ìš”ì†Œë„ ì œí•œë  ê²ƒìž„
# ì´ì „ ìš°ìˆ˜ ë§ˆì„ ì‹¤ìŠµì—ì„œ dp[node][0], dp[node][1]ì¼ ë•Œì˜ ìƒí™©ê³¼ ìœ ì‚¬í•˜ì§€ ì•Šë‚˜ ì‹¶ìŒ

# dp[node][i] : í•´ë‹¹ ë…¸ë“œì— ëŒ€í•œ ì„ íƒ ìœ ë¬´ì— ë”°ë¥¸ ê°€ì¤‘ì¹˜
# dp[node][0] => í•´ë‹¹ ë…¸ë“œë¥¼ ë…ë¦½ ì§‘í•©ìœ¼ë¡œ ì„ ì •í•˜ì§€ ì•ŠëŠ” ê²½ìš° 
# dp[node][1] => í•´ë‹¹ ë…¸ë“œë¥¼ ë…ë¦½ ì§‘í•©ìœ¼ë¡œ ì„ ì •í•˜ëŠ” ê²½ìš°
# ì´ë ‡ê²Œ ì •ì˜í•˜ë©´..
# dp[node][0] += max(dp[child][0], dp[child][1])
# dp[node][1] += dp[child][0]

# ë¬¼ë¡ , ëª…í™•í•˜ê²Œ ì •ì˜í•˜ì§€ëŠ” ëª»í•˜ê² ìœ¼ë‚˜ ìš°ìˆ˜ ë§ˆì„ì²˜ëŸ¼ dfs ì ‘ê·¼ì´ í•„ìš”í•  ê²ƒ ê°™ë‹¤ê³  ëŠë‚Œ
# ë‹¤ë§Œ, ì´ì œ ê° ë…ë¦½ ì§‘í•© Sì— ëŒ€í•´ ì–´ë–»ê²Œ êµ¬ì„±ë˜ì–´ ìžˆëŠ”ì§€ë¥¼ ê¸°ë¡í•´ì•¼ í•¨.
# ë…ë¦½ ì§‘í•© S ë‚´ êµ¬ì„± ìš”ì†Œ ì €ìž¥í•˜ê¸° ìœ„í•œ êµ¬ì¡°ì²´ ì„ ì–¸
# ì–´ë–»ê²Œ? ë„£ëŠëƒ .. ê·¸ë¦¬ê³  ì–´ë–»ê²Œ ìµœëŒ€ ë…ë¦½ ì§‘í•©ì— ëŒ€í•œ êµ¬ì„±ìš”ì†Œë¥¼ ì‹ë³„í•´ì„œ ëŒì–´ì˜¤ëŠëƒ?
# dpì™€ ìœ ì‚¬í•œ êµ¬ì¡°ì²´ S , S = [[0, 0] for _ in range(N + 1)]ë¥¼ ì„ ì–¸í•˜ì—¬
# dpì˜ ê° ê²½ìš°ì— ë”°ë¥¸ node ë° child append ìž‘ì—…ì„ ì²˜ë¦¬í•˜ë©´ ì•Œ ìˆ˜ ìžˆì§€ ì•Šì„ê¹Œ? ì‹¶ìŒ




#ðŸ” Q1. ì´ ë¬¸ì œì˜ í•µì‹¬ ì œì•½ ì¡°ê±´ì€ ë¬´ì—‡ì¸ê°€?
#ê·¸ëž˜í”„ëŠ” ì‚¬ì´í´ì´ ì—†ëŠ” íŠ¸ë¦¬ (ì¦‰, ë¬´ë°©í–¥ & ì—°ê²° & N-1ê°œì˜ ê°„ì„ )

#ê° ë…¸ë“œëŠ” ê°€ì¤‘ì¹˜(ë…ë¦½ ì§‘í•©ì— í¬í•¨ë  ê²½ìš° ì–»ëŠ” ì´ìµ)ë¥¼ ê°€ì§

#í•œ ë…¸ë“œê°€ ë…ë¦½ ì§‘í•©ì— í¬í•¨ë˜ë©´ ì¸ì ‘ ë…¸ë“œëŠ” í¬í•¨í•  ìˆ˜ ì—†ìŒ

#â†’ ì–´ë–¤ ìœ í˜•ì´ ë– ì˜¤ë¥´ë‹ˆ?
#ì´ê±´ ì‚¬ì‹¤ìƒ "ë¶€ë¶„ì§‘í•© ìµœëŒ€ ì´ìµ ì„ íƒ" ë¬¸ì œì¸ë°,
#íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ì¸í•´ DFS ìˆœíšŒë¥¼ í•˜ë©° ì í™”ì‹ì„ êµ¬ì„±í•´ì•¼ í•´.

import sys
from collections import defaultdict
input = sys.stdin.readline


N = int(input())
# ê·¸ëž˜í”„ êµ¬ì„±
graph = defaultdict(list)

# ì¸ë±ìŠ¤ì— ë§žì¶”ì–´ ë…¸ë“œ ë°°ì—´(ì•žì— ì“°ë ˆê¸°ê°’ í•˜ë‚˜ í¬í•¨)
Weight = list(map(int, input().split()))
Weight.insert(0, -1)

# ì–‘ë°©í–¥ ê°„ì„  ì—°ê²° (íŠ¸ë¦¬ì´ë¯€ë¡œ ë°©í–¥ ì—†ìŒ)
for _ in range(N-1):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)

dp = [[0, 0] for _ in range(N + 1)]

# ì§‘í•© ìžë£Œí˜• ì„ ì–¸ (ë…ë¦½ ì§‘í•© S ë‚´ êµ¬ì„± ìš”ì†Œ ì €ìž¥í•˜ê¸° ìœ„í•œ êµ¬ì¡°ì²´)
S = [[[], []] for _ in range(N + 1)]



def dfs(node, parent):
    dp[node][0] = 0
    
    dp[node][1] = Weight[node]
    S[node][1] = [node]
    
    for child in graph[node]:
        if child == parent:
            continue
        dfs(child, node)
        
        # ì„ íƒ ì•ˆ í•œ ê²½ìš°: ìžì‹ ì¤‘ ë” í° ìª½ ì„ íƒ
        # dp[child][0]ì™€ dp[child][1] ê°™ì„ ê²½ìš°ëŠ” ì—†ì„ ê²ƒì´ë¼ ìƒê°í•¨
        if dp[child][0] > dp[child][1]:
          dp[node][0] += dp[child][0]
          S[node][0].extend(S[child][0])
        else:
          dp[node][0] += dp[child][1]
          S[node][0].extend(S[child][1])
        
        # ì„ íƒí•œ ê²½ìš°: ìžì‹ì€ ë¬´ì¡°ê±´ ì œì™¸
        dp[node][1] += dp[child][0]
        S[node][1].extend(S[child][0])
        
#ë…¸ë“œ 1ì„ ë£¨íŠ¸ ë…¸ë“œë¡œ ì§€ì •í•˜ì—¬ dfs ì‹¤ì‹œ(ì–´ëŠ ì ì„ ìž¡ì•„ë„ ìƒê´€ì—†ìœ¼ë‚˜, ì¼ë°˜ì ìœ¼ë¡œ ì²« ë…¸ë“œ ì„¤ì •í•˜ë‹ˆ..)
dfs(1, -1)

print(max(dp[1][0], dp[1][1]))

if (dp[1][0] > dp[1][1]):
  print(" ".join(map(str, sorted(S[1][0]))))
else :
  print(" ".join(map(str, sorted(S[1][1]))))