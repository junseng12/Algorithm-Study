# 🧭 감각 노트: DFS 경로 조건 탐색

## 🎯 목적

- DFS를 단순한 방문 탐색이 아니라  
  **"경로 조건을 만족하는 조합을 찾기 위한 도구"**로 이해한다.
- 특정 깊이, 특정 조건, 특정 경로 형식이 있을 때  
  DFS가 어떻게 **경로 구성과 조건 분기를 함께 처리하는지**를 감각화한다.

---

## 📌 구조 요약

```python
def dfs(node, depth):
    if depth == target_depth:
        if 경로 조건 만족:
            처리()
        return
    visited[node] = True
    for next in graph[node]:
        if not visited[next]:
            dfs(next, depth + 1)
    visited[node] = False
```

- `depth`로 경로 길이 제어
- `visited[]`로 순환 방지 및 백트래킹
- 종료 조건 만족 시 바로 return or exit

---

## 🔍 대표 문제 감각 비교

| 문제                     | 핵심 감각                          | DFS 역할                         |
| ------------------------ | ---------------------------------- | -------------------------------- |
| `13023_ABCDE`            | 깊이 5의 단순 경로 존재 확인       | 길이 제한 DFS + 백트래킹         |
| `1068_트리`              | 조건 분기 후 리프 노드 개수 카운트 | 삭제된 노드 제외 + 리프 판별 DFS |
| `2644_촌수계산`          | 두 노드 사이 촌수                  | 조건 만족 시 깊이 반환           |
| `11724_연결 요소의 개수` | 연결된 구성 개수                   | 방문 체크 + 카운트용 DFS         |

---

## 💡 기억 키워드

- DFS는 “방문”이 아니라 **“조건 만족하는 경로를 찾는 여정”**
- **깊이 제한** + **방문 복원** + **종료 조건** 3요소가 핵심
- 방문을 풀어야 다음 경로에서 다시 사용할 수 있다 (백트래킹)
- 종료 조건이 명확할 때 `exit(0)`도 유용

---

## 🧩 적용 가능한 패턴

| 유형      | 패턴                            |
| --------- | ------------------------------- |
| 길이 제한 | `depth == target_depth`         |
| 조건 만족 | `if condition:` inside DFS      |
| 결과 누적 | `if 조건: result += 1`          |
| 구성 저장 | `path.append(node)` + backtrack |

---

## 📂 실전 감각 확장 예시

- **조건 분기형 DFS**: 트리 노드 삭제, 구성 요소 분리
- **경로 복원형 DFS**: 최장 경로, 최소 이동 수, 조합 생성
- **백트래킹 DFS**: 순열, N-Queen, 수열 조건
